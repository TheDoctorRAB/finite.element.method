inv       program transport
c	
c	-----------------------------------------------------------------
c	Robert Angelo Borrelli
c	01 May 2011
c	-----------------------------------------------------------------
c	v3.34
c	-----------------------------------------------------------------
c	This version does not compute energy norm, courant number (DNP)
c	They are just commented out
c	-----------------------------------------------------------------
c	This FORTRAN program produces normalized radionuclide 
c	concentration in the fluid phase and fluid phase release rate at
c	each location in the spatial domain
c	-----------------------------------------------------------------
c	The differential equation utilized for this program is a standard 
c	diffusion-advection-reaction equation
c	-----------------------------------------------------------------
c	The domain contains a region of bentonite extrusion
c	and a region containing only groundwater
c	-----------------------------------------------------------------
c	The region of bentonite extrusion will contain a solid advection 
c	component
c	-----------------------------------------------------------------
c	The program is divided into three modules: preprocessor,
c	processor, postprocessor
c	-----------------------------------------------------------------
c	Each module is described in detail below
c	-----------------------------------------------------------------
c	In the region of bentonite extrusion, parameters in the
c	differential equation are evaluated based on the void ratio 
c	distribution
c	-----------------------------------------------------------------
c	The void ratio distribution is generated by SABRE6 and imported
c	into this program
c	-----------------------------------------------------------------
c	In the region beyond the extrusion, parameters are determined 
c	based on physical conditions; i.e., fluid porosity is unity in
c	the region
c	-----------------------------------------------------------------
c	The solution is obtained by the finite element method (Galerkin)
c	-----------------------------------------------------------------
c	The solver engine is a preconditioned conjugate gradient solver
c	scheme
c	-----------------------------------------------------------------
c	New features include:
c	Diffusion coefficient for tortuous media (D')
c	Normalization of diffusion coefficients (ksi_F,ksi_S)
c	Removal of A and B matrices and associated functions
c	'_bar' extensions on matrices are kept because there are 
c	too many of them to change
c	Void diffusivity function
c	Second order void ratio derivative function
c	First order fluid porosity function
c	Changed beta parameter to different form
c	Changed beta derivative to different form
c	Added a subroutine to calculate radionuclide residence time
c	in the bentonite extrusion model
c	Added module (scheme within a subroutine) to make peclet number
c	as a function
c	Added subroutine to calculate courant number
c	Added subroutine to calculate average/element courant number
c	and peclet number
c	Added functional version of mass flux; i.e., m*r+b, with
c	isoparametric map
c	Added eta ratio by release rate at the tip
c	Mesh changes with time; break at the tip at each time step
c	Increased node breakers
c	-----------------------------------------------------------------
c	
c	Pre processing module
c	
c	-----------------------------------------------------------------
c	(1): procedural data is imported
c	   tandr: time and tip location generated by SABRE
c	   node_mesh: structure of the mesh in the SABRE execution
c	   void_ratio: void ratio at the nodes generated by SABRE
c	   time_domain: number of time steps that the user wants to run,
c	   total time steps, total time steps + 0 time
c	   SABRE: total number of nodes in the SABRE execution
c	   mesh_generation: structure of the transport mesh, vis a vis
c	   node locations
c	   physical_domain: location of the node breaks from mesh
c	   generation on the physical domain
c	   physical_constants: physical data, such as diffusion
c	   coefficient, G, etc., listed below
c	   quadrature: gaussian quadrature, for numerical integration
c	   in isoparametric space
c	-----------------------------------------------------------------
c	(2): necessary constants are computed
c	-----------------------------------------------------------------
c	(3): time is transformed to t bar (nondimensionalized)
c	-----------------------------------------------------------------
c	(4): mesh construction
c	   SABRE considers a mesh from R0 to R(t) at each time step (tn).
c	   So while each mesh contains the same number of nodes, the 
c	   location of the nodes are different at each tn. Beyond the tip
c	   r > R(tn), e = infinity because the assumption is made that no
c	   solid material is present at r > R(t). 
c	
c	   For the transport code, the mesh needs to be "extended"
c	   to include nodal locations r > R(t). 
c	
c	   The mesh is fixed from r bar = R0/R0 to r bar = R_sink/R0.
c	   There is a different mesh for each time step, where it has two 
c	   primary subdomains: R0/R0 to R(t)/R0 to R_sink/R0.
c	
c	   The *number* of nodes in each subdomain is the same. 
c	   So it is #1 to #tip_break from R0/R0 to R(t)/R0, and 
c	   #tip_break to #Node from R(t)/R0 to R_sink/R0. 
c	
c	   For the default mesh, set NBreakX1,X2,X3=tip_break
c	   and NBreakS1,S2=Node; all RBreak variables=1 (see (1))
c	   
c	   Refinement is built in.  See (4) 
c	   The jacobians are also calculated here.
c	-----------------------------------------------------------------
c	(5): void ratio distribution
c	   The void ratio distribution from SABRE will have to be 
c	   converted to the standardized mesh in order to calculate
c	   the field parameters.
c
c         Since the location of the bentonite tip is important, the mesh 
c         is constructed in order to incorporate the location of the tip
c
c         A mesh is first calculated without the location of the tip
c
c         Then, an algorithm determines the node number for where the 
c         tip (for each time step) should be inserted
c
c         The mesh is then constructed by inserting the location of the
c         tip into the existing mesh, and the node number for the tip
c         is recorded
c
c         The jacobians are also calculated here
c	-----------------------------------------------------------------
c	Step 5: SABRE basis functions
c
c         These are linear functions in r bar that will be used to
c         construct the FEM solutions to void ratio on the SABRE mesh
c
c	Step 6: transport basis functions
c
c         These are linear functions in r bar that will be used to
c         construct the FEM solution to void ratio once the SABRE
c         FEM solutions are converted to the standard transport mesh
c
c	Step 7: SABRE FEM solutions
c
c         The linear functions for void ratio are constructed for the
c         SABRE mesh
c
c	Step 8: void ratio on the transport mesh
c
c         Values for the void ratio are evaluated on the nodes of the
c	   transport mesh
c         by using the FEM functions constructed on the SABRE mesh
c
c	Step 9: transport FEM functions
c          
c         The linear functions for the void ratio are constructed for 
c         transport mesh, based on the calculations from the SABRE mesh
c
c         These FEM functions are then used to construct functions for
c         field parameters
c
c	Step 10: mapping to isoparamteric space
c
c          Linear functions are created for the isoparametric space; 
c          i.e., constuction of rbar to rbar(xi).
c
c          Linear functions for the void ratio FEM functions are constructed for
c          the isoparametric space
c
c	Step 11: derivative scheme
c
c          The derivative scheme is constructed in order to construct linear functions
c          for the derivative of the void ratio solution
c          
c          These functions will be used in construction of the parameter functions    
c 
c          This scheme is used because continuity of the derivative is not enforced in
c          the FEM solution; it is based on the basis functions which are functions of
c          the mesh only
c
c	Step 12: FEM field parameter functions
c
c          The linear FEM functions that were constructed on the transport mesh
c          are used to assemble functions for each of the field paramters
c
c          The linear FEM functions for the dimensionless parameters (alpha, etc.)
c          are also constructed here
c
c	Step 14: Mapping
c
c          The field parameters are mapped into the isoparametric space
c 
c	Step 15: nodal values
c
c          The values of all the parameters on the nodes are computed
c
c          These values are only computed to the tip for each time step
c
c          From the node after the tip to the end of the mesh, 
c	    the physical are enforced
c	-----------------------------------------------------------------
c	
c	Processing module
c	
c	-----------------------------------------------------------------
c	The solution is obtained for r bar in discrete t bar steps.
c	In the code, t1 is n=2; n=1 is the initial condition (t=0).
c	-----------------------------------------------------------------
c	Step 1: Data
c    
c         New data files that are imported in subroutine (1) include:
c         
c         boundary_condition: contains the initial/boundary condition
c         pcg_processor: contains the convergence tolerance for PCG 
c	   solver
c                         
c
c	Step 2: n=2 and n=3
c
c         The solution is obtained by first order, backward euler scheme
c         Mass matrix is calculated first
c         Stiffness matrix is calculated second
c         The representative mass and stiffness matrices are added
c         The representative mass and stiffness matrices are
c	   preconditioned
c         The force vector is not calculated because boundary conditions
c	   are specified at the nodes
c         The conjugate gradient method is used to obtain the solution
c         Solution data is loaded into a large matrix for export
c         Linear interpolation functions are assembled
c 
c	Step 3: n=4 to end
c 
c         The solution is obtained by implicit trapezoid rule
c         Mass matrix is calculated first
c         Stiffness matrix is calculated second
c         The representative mass and stiffness matrices are added
c         The representative mass and stiffness matrices are
c	   preconditioned
c         The force vector is not calculated because boundary conditions
c	   are specified at the nodes
c         The conjugate gradient method is used to obtain the solution
c         Solution data is loaded into large matrix for export
c         Linear interpolation functions are assembled
c  
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c	Post processing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c	Step 1: derivative scheme
c
c         The derivative scheme is constructed in order to construct
c	   linear functions for derivative of the radionulide solution
c          
c         These functions will be used in construction release rate 
c	   function
c 
c         This scheme is used because continuity of the derivative is
c	   not enforced in the FEM solution; it is based on the basis
c	   functions which are functions of the mesh only
c
c	Step 2: FEM radionuclide functions
c
c         The linear FEM functions that were constructed on the 
c	   transport mesh are used to compute the release rate
c
c	Step 3: release rates at the nodes
c
c         The release rate is calculated at the nodes for each time step
c 
c	Step 4: release rate tip
c
c         The nodal release rate at the tip for each time step is 
c	   assembled
c
c	Step 5: mass ratio
c
c	   The ratio of mass in the bentonite extrusion region to
c	   total mass in domain is calculated
c
c	Step 6: residence time
c
c	   The residence time of the radionuclide in the bentonite
c	   extrusion region is calculated
c	----------------------------------------------------------------- 
c	
c	-----------------------------------------------------------------
c	
c	global variable declaration
c	
c	-----------------------------------------------------------------
	implicit none
c	-----------------------------------------------------------------
c	loops
	integer e,i,j,k,n
c	-----------------------------------------------------------------
c	output flag
	integer write_file
c	-----------------------------------------------------------------
c	number of gaussian integration points
	integer gauss_points
	parameter(gauss_points=4)
c	-----------------------------------------------------------------
c	time
	integer number,full_step
	parameter(number=4,full_step=3)
c	-----------------------------------------------------------------
c	SABRE mesh
	integer SABRE_Node,SABRE_Element
	parameter(SABRE_Node=2008,SABRE_Element=SABRE_Node-1)
c	-----------------------------------------------------------------
c	transport mesh
	integer Node,Element
	integer tip_break
	integer NBreakX1,NBreakX2,NBreakX3,NBreakS1,NBreakS2
	parameter(Node=15001,Element=Node-1)
	parameter(tip_break=10001)
	parameter(NBreakX1=tip_break,NBreakX2=tip_break)
	parameter(NBreakX3=tip_break)
	parameter(NBreakS1=Node,NBreakS2=Node)
c	-----------------------------------------------------------------
c	physical domain
	double precision R0
	double precision RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2
	double precision R_Sink
c	-----------------------------------------------------------------
c	void ratio
	double precision e0,eT
c	-----------------------------------------------------------------
c	diffusion coefficients for radionuclide
	double precision DF,DS,D_prime,ksi_F,ksi_S
c	-----------------------------------------------------------------
c	sorption
	double precision sorption_distribution,KD
c	-----------------------------------------------------------------
c	void diffusivity
	double precision D0,G
c	-----------------------------------------------------------------
c	decay constant
	double precision lambda
c	-----------------------------------------------------------------
c	parameters for initial condition and for region beyond extrusion
	double precision fluid_porosity_physical, solid_porosity_physical
	double precision retardation_physical
	double precision A_physical,B_physical
	double precision fluid_velocity_physical,solid_velocity_physical
	double precision peclet_physical
	double precision thiele
	double precision alpha_bar_physical
	double precision beta_bar_physical
	double precision gamma_bar_physical
	double precision theta_bar_physical
	double precision bentonite_density
c	-----------------------------------------------------------------
c	boundary conditions
	double precision boundary_condition_1
	double precision boundary_condition_2
c	-----------------------------------------------------------------
c	procedural for solver
	double precision threshold
	double precision delta
	double precision chi
	double precision epsilon
	double precision numerator,denominator
c	-----------------------------------------------------------------
c	zero flag for radionuclide derivative
	double precision zero_flag
	parameter(zero_flag=1.0d-12)
c	-----------------------------------------------------------------
c	
c	-----------------------------------------------------------------
c	
c	matrices
c	
c	-----------------------------------------------------------------
c	gaussian quadrature
	double precision quadrature(gauss_points,2)
c	-----------------------------------------------------------------
cSABRE mesh      
double precision node_mesh(SABRE_Node)
c	-----------------------------------------------------------------
creal time and corresponding tip location
double precision tandr(number,2)
c	-----------------------------------------------------------------
cvoid ratio distribution from SABRE
double precision SABRE_nodal_data((full_step+1)*SABRE_Node)
c	-----------------------------------------------------------------
c      dimensionless time
double precision time_tau(number,4)
double precision dt(full_step,2)
c	-----------------------------------------------------------------
cmesh initialization
double precision SABRE_FEM_mesh((number*SABRE_Node),3)
double precision SABRE_h(number*SABRE_Element)
c	-----------------------------------------------------------------
cmesh standardization
cdouble precision FEM_mesh_no_tip(base_mesh)
double precision FEM_mesh(Node,full_step)
double precision h(Element,full_step)
double precision FEM((number*Element),4)
double precision dFEM((number*Element),4)
cdouble precision radionuclide_FEM(Element*full_step,6)
cdouble precision dradionuclide_FEM(Element*full_step,6)
cdouble precision release_rate_FEM(Element*full_step,6)
c	
cSABRE linear interpolation functions
double precision SABRE_FEM((number*SABRE_Element),4)
c	
cmapping
double precision LocalParametricMapping(Element,3)
double precision ShapeFunction(2,2)
double precision dShapeFunction(1,2)
c       
cprocedural matrices for derivative scheme
double precision R((2*Element),2)
double precision S((2*Element),2)
double precision d_factor(Node)
double precision l_factor(Element)
double precision inverse_R(Node,Node)
c       
cdimensionless field parameters       
double precision alpha_bar(Element*number,6)
double precision beta_bar(Element*number,6)
double precision gamma_bar(Element*number,6)
double precision theta_bar(Element*number,6)
c
c      procedural
c      these matrices will be exported for graphing
c      field parameters
       double precision void_ratio_nodal(Node*number,5)
       double precision dvoid_ratio_nodal(Node*number,5)
       double precision fluid_porosity_nodal(Node*number,5)
       double precision solid_porosity_nodal(Node*number,5)
       double precision retardation_nodal(Node*number,5)
       double precision A_nodal(Node*number,5)
       double precision B_nodal(Node*number,5)
       double precision fluid_velocity_nodal(Node*number,5)
       double precision solid_velocity_nodal(Node*number,5)
       double precision peclet_nodal(Node*number,5)
       double precision alpha_bar_nodal(Node*number,5)
       double precision beta_bar_nodal(Node*number,5)
       double precision gamma_bar_nodal(Node*number,5)
       double precision theta_bar_nodal(Node*number,5)
c
c	radionuclide
	double precision radionuclide_nodal(Node*full_step,5)
c	double precision dradionuclide_nodal(Node*full_step,5)
c       double precision release_rate_nodal(Node*full_step,5)
c       double precision release_rate_graph(full_step,(Node+1))
c       double precision release_rate_raw(Node,(full_step+1))
c       double precision release_rate_tip(full_step,3)
c
c	FEM matrices
       double precision mass(2*Element,2)
	double precision stiffness(2*Element,2)
c
c	solver matrices
	double precision preconditioner(2*Element,2)
	double precision preconditioned_stiffness(2*Element,2)
	double precision preconditioned_force(Node)
	double precision guess(Node)
	double precision residual(Node)
	double precision z(Node)
c
c	solution matrices
	double precision N0(Node)
	double precision N1(Node-2)
	double precision solution(Node)
	double precision solutionback(Node)
	double precision nextstep(Node)
	double precision ndot(Node)
	double precision ndotback(Node)
c
c      zero flag matrix for radionuclide derivative
       double precision dflag(full_step,4)
c
c      energy_norm DNP
c      double precision energy_norm_element(Element,5)
c      double precision energy_norm(1,3)
c
c      mass ratio
c       double precision delta_ratio_element(full_step*Element,5)
c       double precision delta_ratio(full_step,5)
c
c	residence time
c	double precision eta_ratio_element(full_step*Element,5)
c	double precision eta_ratio(full_step,10)
c
c	courant number DNP
c	double precision courant_nodal(Node*full_step,5)
c	double precision courant(Element*full_step,6)
c	double precision courant_grid(Element*full_step,7)
c	
c	peclet number
 	double precision peclet(Element*number,6)
c	double precision peclet_grid(Element*full_step,5)
c	
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      functions
c
c      linear interpolation
       double precision evaluation_linear
c
c	field parameters
	double precision evaluation_fluid_porosity
       double precision evaluation_solid_porosity
       double precision evaluation_retardation
       double precision evaluation_A_matrix
       double precision evaluation_B_matrix
       double precision evaluation_fluid_velocity
       double precision evaluation_fluid_velocity_tip
       double precision evaluation_solid_velocity
       double precision evaluation_peclet
       double precision evaluation_peclet_tip
       double precision evaluation_alpha_bar
       double precision evaluation_dalpha_bar       
       double precision evaluation_beta_bar
       double precision evaluation_dbeta_bar
       double precision evaluation_beta_bar_tip
       double precision evaluation_dbeta_bar_tip
       double precision evaluation_gamma_bar
       double precision evaluation_theta_bar
       double precision evaluation_theta_bar_tip
c
c      mapping
       double precision evaluation_isoparametric_m
       double precision evaluation_isoparametric_b
c
c      variables used in the functions       
       double precision m
       double precision dm
       double precision b
       double precision d1,d2
       double precision p,q
       double precision x
       double precision x1
       double precision jacobian
       double precision fp
       double precision a
       double precision delta_t
       double precision l
       double precision ab
       double precision an
       double precision ap
c      
c      gaussian quadrature
       double precision gaussian_quadrature_linear
       double precision m1,b1
 	double precision m2,b2
	double precision fm,fb
	double precision iso_map_m,iso_map_b
	double precision xi       
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      common blocks
c
       common /output_file/ write_file
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      start pre processing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      read data from the input files
c      (1)
       call read_input_files(gauss_points,SABRE_Node,
     * number,full_step,quadrature,node_mesh,tandr,
     * SABRE_nodal_data,R0,
     * RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2,
     * R_Sink,e0,eT,DF,DS,D_prime,sorption_distribution,D0,G,lambda,
     * fluid_porosity_physical,solid_porosity_physical,
     * retardation_physical,A_physical,B_physical,
     * fluid_velocity_physical,solid_velocity_physical,
     * peclet_physical,alpha_bar_physical,
     * beta_bar_physical,gamma_bar_physical,
     * bentonite_density,write_file,
     * boundary_condition_1,
     * boundary_condition_2,
     * threshold)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      calculations for input parameters
c      (2)
       call input_calculations(sorption_distribution,
     * bentonite_density,lambda,R0,DF,DS,D_prime,KD,thiele,
     * theta_bar_physical,ksi_F,ksi_S)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      start preprocessing
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      convert real time to dimensionless time and flag the tip
c      (3)
       call convert_time(number,full_step,tandr,DF,
     * R0,time_tau,dt)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      transport model mesh initialization
c      (4)
	call mesh_initialization(
     * number,full_step,
     * SABRE_Node,SABRE_Element,
     * Node,Element,
     * R0,
     * tip_break,
     * RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2,
     * R_Sink,
     * NBreakX1,NBreakX2,NBreakX3,NBreakS1,NBreakS2,
     * tandr,
     * node_mesh,SABRE_nodal_data,
     * SABRE_FEM_mesh,SABRE_h)
	stop     
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      formulate linear interpolation functions on model mesh for void
c	ratio distribution
c      (5)
c       call void_ratio_distribution(
c     * number,full_step,
c     * SABRE_Node,SABRE_Element,
c     * Node,Element,
c     * e0,eT,
c     * time_tau,
c     * SABRE_FEM_mesh,SABRE_h,SABRE_FEM,
c     * FEM_mesh,h,
c     * void_ratio_nodal,FEM)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      formulate mapping to isoparamteric space
c      (6)
c       call isoparametric_mapping(Node,Element,FEM_mesh,h,
c     * LocalParametricMapping)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      formulate shape functions
c      (7)
c       call make_shape_function(ShapeFunction,dShapeFunction)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      start derivative scheme
c      (8)
c       call derivative_scheme(
c     * gauss_points,quadrature,
c     * number,full_step,
c     * Node,Element,
c     * time_tau,
c     * FEM_mesh,h,
c     * ShapeFunction,dShapeFunction,
c     * LocalParametricMapping,
c     * void_ratio_nodal, 
c     * R,S,
c     * d_factor,l_factor,
c     * inverse_R,
c     * dvoid_ratio_nodal,dFEM)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      end field parameter assembly
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      evaluate values of functions at nodes and linear interpolation 
c	functions
c      (9)
c       call nodal_values(
c     * number,full_step,
c     * Node,Element,
c     * R0,
c     * time_tau,
c     * dt,
c     * FEM_mesh,h,
c     * fluid_porosity_physical,
c     * solid_porosity_physical,
c     * retardation_physical,
c     * A_physical,
c     * B_physical,
c     * fluid_velocity_physical,
c     * solid_velocity_physical,
c     * peclet_physical,
c     * alpha_bar_physical,
c     * beta_bar_physical,
c     * gamma_bar_physical,
c     * theta_bar_physical,
c     * D0,G,KD,DF,DS,ksi_F,ksi_S,
c     * void_ratio_nodal,
c     * dvoid_ratio_nodal,
c     * fluid_porosity_nodal,
c     * solid_porosity_nodal,
c     * retardation_nodal,
c     * A_nodal,
c     * B_nodal,
c     * fluid_velocity_nodal,
c     * solid_velocity_nodal,
c     * peclet_nodal,
c     * alpha_bar_nodal,
c     * beta_bar_nodal,
c     * gamma_bar_nodal,
c     * theta_bar_nodal,
c     * peclet,
c     * alpha_bar,
c     * beta_bar,
c     * gamma_bar,
c     * theta_bar,
c     * LocalParametricMapping)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      end pre processing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      start processing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute normalized radionuclide concentration in fluid phase
c      (10)
c       call radionuclide_solver(
c     * number,full_step,
c     * Node,Element,
c     * gauss_points,
c     * boundary_condition_1,
c     * boundary_condition_2,
c     * threshold,
c     * delta,chi,epsilon,
c     * numerator,denominator,
c     * time_tau,
c     * dt,
c     * FEM_mesh,h,
c     * quadrature,
c     * alpha_bar,
c     * beta_bar,
c     * gamma_bar,
c     * theta_bar,
c     * LocalParametricMapping,
c     * ShapeFunction,dShapeFunction,
c     * mass,stiffness,
c     * preconditioner,
c     * preconditioned_stiffness,
c     * preconditioned_force,
c     * guess,residual,z,
c     * N0,N1,
c     * solution,solutionback,
c     * nextstep,
c     * ndot,ndotback,
c     * radionuclide_nodal,
c     * radionuclide_FEM)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      end processing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      start postprocessing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute normalized radionuclide release rate
c      (11)
c       call release_rate(
c     * number,full_step,
c     * Node,Element,
c     * D_prime,R0,
c     * zero_flag,
c     * time_tau,
c     * FEM_mesh,h,
c     * LocalParametricMapping,
c     * fluid_porosity_nodal,
c     * peclet_nodal,
c     * S,
c     * inverse_R,
c     * radionuclide_nodal,
c     * radionuclide_FEM,
c     * dradionuclide_nodal,
c     * dradionuclide_FEM,
c     * release_rate_nodal,
c     * release_rate_FEM,
c     * release_rate_graph,
c     * release_rate_raw,
c     * release_rate_tip,
c     * dflag)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute energy norm DNP
c      (12)
c       call evaluate_energy_norm(
c     * number,full_step,
c     * Node,Element,
c     * gauss_points,
c     * quadrature,p
c     * time_tau,
c     * FEM_mesh,h,
c     * LocalParametricMapping,
c     * gamma_bar,
c     * dradionuclide_FEM,
c     * energy_norm_element,
c     * energy_norm)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute mass ratio
c      (14)
c       call mass_ratio(
c     * number,full_step,
c     * Node,Element,
c     * gauss_points,
c     * quadrature,
c     * time_tau,
c     * FEM_mesh,h,
c     * LocalParametricMapping,
c     * alpha_bar,
c     * radionuclide_FEM,
c     * delta_ratio_element,
c     * delta_ratio)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute residence time
c      (15)
c       call residence_time(
c     * number,full_step,
c     * Node,Element,
c     * gauss_points,
c     * quadrature,
c     * R0,D_prime,
c     * time_tau,
c     * FEM_mesh,h,
c     * LocalParametricMapping,
c     * release_rate_tip,
c     * release_rate_FEM,
c     * delta_ratio,
c     * eta_ratio_element,
c     * eta_ratio)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      compute courant number DNP
c      (16)
c       call courant_number(
c     * number,full_step,
c     * Node,Element,
c     * gauss_points,
c     * quadrature,
c     * time_tau,dt,
c     * FEM_mesh,h,
c     * LocalParametricMapping,
c     * fluid_velocity_nodal,
c     * alpha_bar_nodal,
c     * peclet,
c     * peclet_grid,
c     * courant,
c     * courant_nodal,
c     * courant_grid)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      end postprocessing module
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      end of the main program
c
       end
c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      subroutines
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (1)
c      read data from the input files subroutine
       subroutine read_input_files(gauss_points,SABRE_Node,
     * number,full_step,quadrature,node_mesh,tandr,
     * SABRE_nodal_data,R0,
     * RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2,     
     * R_Sink,e0,eT,DF,DS,D_prime,sorption_distribution,D0,G,lambda,
     * fluid_porosity_physical,solid_porosity_physical,
     * retardation_physical,A_physical, B_physical,
     * fluid_velocity_physical,solid_velocity_physical,
     * peclet_physical,alpha_bar_physical,
     * beta_bar_physical,gamma_bar_physical,
     * bentonite_density,write_file,
     * boundary_condition_1,
     * boundary_condition_2,
     * threshold)
c
c      variables and matrices
c
       implicit none
c
c      loops
       integer i,j
c
c      quadrature
       integer gauss_points
       double precision quadrature(gauss_points,2)
c
c      SABRE mesh
       integer SABRE_Node
       double precision node_mesh(SABRE_Node)
c       
c      time
       integer number,full_step
       double precision tandr(number,2)
c
c      void ratio distribution from SABRE
       double precision SABRE_nodal_data((full_step+1)*SABRE_Node)
c       
c      physical domain
       double precision R0
       double precision RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2
       double precision R_Sink
c       
c      void ratio
       double precision e0,eT
c
c      diffusion coefficients for radionuclide
       double precision DF,DS,D_prime
c
c      sorption
       double precision sorption_distribution
c
c      void diffusivity
       double precision D0,G
c
c      decay constant
       double precision lambda
c
c      parameters for initial condition and for region beyond extrusion
       double precision fluid_porosity_physical, solid_porosity_physical
       double precision retardation_physical
       double precision A_physical, B_physical
       double precision fluid_velocity_physical, solid_velocity_physical
       double precision peclet_physical
       double precision alpha_bar_physical
       double precision beta_bar_physical
       double precision gamma_bar_physical
       double precision bentonite_density
c
c	boundary conditions
	double precision boundary_condition_1
	double precision boundary_condition_2
c
c	procedural for solver
	double precision threshold
c
c      output flag
       integer write_file
c
c      open input files
       open(10,file='quadrature.inp')
       open(11,file='node_mesh.inp')
       open(12,file='tandr.inp')
       open(13,file='voidratio.inp')
       open(14,file='physical_domain.inp')
       open(15,file='physical_constants.inp')
	open(16,file='boundary_condition.inp')
	open(17,file='pcg_processor.inp')
       open(18,file='write_file.inp')
c
c      read input files
c
c      quadrature
       do 1 i=1,gauss_points
         read(10,*) (quadrature(i,j),j=1,2)
1      continue
c
c      SABRE mesh
       do 2 i=1,SABRE_Node
        read(11,*) node_mesh(i) 
2      continue
c
c      time and tip location
       do 3 i=1,number
        read(12,*) (tandr(i,j),j=1,2)
3      continue
c
c      void ratio distribution from SABRE
       do 4 i=1,((full_step+1)*SABRE_Node)
        read(13,*) SABRE_nodal_data(i)
4      continue
c
c      physical domain
	read(14,*) R0       
	read(14,*) RBreakX1
       read(14,*) RBreakX2
       read(14,*) RBreakX3
       read(14,*) RBreakS1
       read(14,*) RBreakS2
	read(14,*) R_sink
c
c      physical constants
       read(15,*) e0
       read(15,*) eT
       read(15,*) DF
       read(15,*) DS
       read(15,*) sorption_distribution
       read(15,*) D0
       read(15,*) G
       read(15,*) lambda
       read(15,*) fluid_porosity_physical
       read(15,*) solid_porosity_physical
       read(15,*) retardation_physical
       read(15,*) A_physical
       read(15,*) B_physical
       read(15,*) fluid_velocity_physical
       read(15,*) solid_velocity_physical
       read(15,*) peclet_physical
       read(15,*) bentonite_density
       read(15,*) alpha_bar_physical
       read(15,*) beta_bar_physical
       read(15,*) gamma_bar_physical
       read(15,*) D_prime
c
c	boundary conditions
	read(16,*) boundary_condition_1
	read(16,*) boundary_condition_2
c
c	procedural for solver
	read(17,*) threshold
c
c      write flag
       read(18,*) write_file
c
c      close input files
c
       close(10)
       close(11)
       close(12)
       close(13)
       close(14)
       close(15)
       close(16)
       close(17)
       close(18)
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (2)
c      calculations for input parameters
       subroutine input_calculations(sorption_distribution,
     * bentonite_density,lambda,R0,DF,DS,D_prime,KD,thiele,
     * theta_bar_physical,ksi_F,ksi_S)
c
c      variables
c
       implicit none
c
       double precision sorption_distribution
       double precision bentonite_density
       double precision lambda
       double precision R0
       double precision DF,DS,D_prime
       double precision ksi_F,ksi_S
       double precision KD
       double precision thiele
       double precision theta_bar_physical
c
c      calculations
c
       KD=sorption_distribution*bentonite_density
       thiele=((lambda*R0*R0)/(DF))
       theta_bar_physical=thiele
       ksi_F=D_prime/DF
       ksi_S=DS/DF
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (3)
c      convert real time to dimensionless time and flag the tip
       subroutine convert_time(number,full_step,tandr,DF,
     * R0,time_tau,dt)
c
c      variables
c
       implicit none       
c
       integer n,j
       integer number,full_step
       double precision DF, R0
       double precision tandr(number,2)
       double precision time_tau(number,4)
       double precision dt(full_step,2)

       do 1 n=1,(full_step+1)
        time_tau(n,1)=tandr(n,1)
        time_tau(n,2)=((DF)/(R0*R0))*tandr(n,1)
        time_tau(n,3)=n
        time_tau(n,4)=tandr(n,2)/R0
1      continue
c
       do 2 n=1,full_step
        dt(n,1)=time_tau((n+1),1)-time_tau(n,1)
        dt(n,2)=time_tau((n+1),2)-time_tau(n,2)
2      continue        
c	-----------------------------------------------------------------
c	write output
	open(20,file='time_tau.out')
	do 10 n=1,number
	 write(20,*) (time_tau(n,j),j=1,4)
10	continue        
c	-----------------------------------------------------------------
c	end of subroutine
       return
       end
c	-----------------------------------------------------------------
c	(4)
c	transport model mesh initialization
c	
	subroutine mesh_initialization(
     * number,full_step,
     * SABRE_Node,SABRE_Element,
     * Node,Element,
     * R0,
     * tip_break,
     * RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2,
     * R_Sink,
     * NBreakX1,NBreakX2,NBreakX3,NBreakS1,NBreakS2,
     * tandr,
     * node_mesh,SABRE_nodal_data,
     * SABRE_FEM_mesh,SABRE_h)
c	-----------------------------------------------------------------
c	
c	variables
c	
c	-----------------------------------------------------------------
	implicit none       
c	-----------------------------------------------------------------
       integer e,i,j,n
       integer number,full_step
       integer SABRE_Node,SABRE_Element
       integer Node,Element
       double precision R0
       integer tip_break
       double precision RBreakX1,RBreakX2,RBreakX3,RBreakS1,RBreakS2
       double precision R_Sink
       integer NBreakX1,NBreakX2,NBreakX3,NBreakS1,NBreakS2
       double precision tandr(number,2)
       double precision node_mesh(SABRE_Node)
       double precision SABRE_nodal_data((full_step+1)*SABRE_Node)
       double precision SABRE_FEM_mesh((number*SABRE_Node),3)
       double precision SABRE_h(number*SABRE_Element)
       double precision FEM_mesh(Node,full_step)
       double precision h(Element,full_step)
c	-----------------------------------------------------------------
       integer write_file
       common /output_file/ write_file
c	-----------------------------------------------------------------
c	assemble void ratio data with the nodes on the SABRE mesh
c	
       do 2 n=1,number
        do 1 i=1,SABRE_Node
         SABRE_FEM_mesh((i+(n-1)*SABRE_Node),1)=tandr(n,1)
         SABRE_FEM_mesh((i+(n-1)*SABRE_Node),2)=
     *    (R0+(node_mesh(i)*(tandr(n,2)-R0)))/(R0)     
         SABRE_FEM_mesh((i+(n-1)*SABRE_Node),3)=
     *    SABRE_nodal_data(i+(n-1)*SABRE_Node)
1       continue        
2      continue
c	
       do 4 n=1,number
        do 3 e=1,SABRE_Element
         SABRE_h(e+(n-1)*SABRE_Element)=
     *    SABRE_FEM_mesh((e+1)+(n-1)*SABRE_Node,2)-
     *    SABRE_FEM_mesh(e+(n-1)*SABRE_Node,2)    
3       continue        
4      continue        
c	-----------------------------------------------------------------
c	mesh standard default
c	the mesh is fixed from r bar = R0/R0 to r bar = R_sink/R0
c	there is a different mesh for each time step
c	it has two primary subdomains
c	R0/R0 to R(t)/R0 to R_sink/R0
c	
c	the *number* of nodes in each subdomain is the same for all time
c	this is determined by tip_break
c	so it is #1 to #tip_break from R0/R0 to R(t)/R0
c	and #tip_break to #Node from R(t)/R0 to R_sink/R0
c	
c	to set the default
c	NBreakX1,X2,X3=tip_break; NBreakS1,S2=Node
c	all RBreak variables=1
c	       
c	mesh refinement
c	the extrusion region can be refined into 4 subdomains
c	the beyond extrusion region can be refined for 3 of them
c	the NBreaks define the number of nodes per region
c	but they are numbered consecutively! 1,501,701,1001,1101, etc.
c	the RBreaks are the fraction of the subdomain, NOT refinement
c	RBreakX1,X2,X3 are for the extrusion region
c	RBreakS1,S2 are for the region beyond
c	numbered consecutively!
c	
c	so it goes like this, RBreakX1=.5 and NBreak1=101 
c	which means from R0 to .5*(tip_break-R0) there are 101 nodes
c	
	do 6 n=1,full_step
	 FEM_mesh(1,n)=R0/R0
	 FEM_mesh(Node,n)=R_sink/R0
	 FEM_mesh(tip_break,n)=tandr(n+1,2)/R0
	 do 5 i=2,(Node-1)
	  if (i.LT.tip_break) then
	   if (i.LE.NBreakX1) then
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      ((RBreakX1*(tandr(n+1,2)-R0))/(NBreakX1-1))/(R0)
	   else if ((i.GT.NBreakX1).AND.(i.LE.NBreakX2)) then
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      (((RBreakX2-RBreakX1)*(tandr(n+1,2)-R0))/
     *      (NBreakX2-NBreakX1))/(R0)
	   else if ((i.GT.NBreakX2).AND.(i.LE.NBreakX3)) then          
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      (((RBreakX3-RBreakX2)*(tandr(n+1,2)-R0))/
     *      (NBreakX3-NBreakX2))/(R0)
	   else if (i.GT.NBreakX3) then
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      (((1-RBreakX3)*(tandr(n+1,2)-R0))/(tip_break-NBreakX3))/(R0)
	   end if
	  else if (i.GT.tip_break) then
	   if (i.LE.NBreakS1) then           
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      ((RBreakS1*(R_sink-tandr(n+1,2)))/(NBreakS1-tip_break))/(R0)
          else if ((i.GT.NBreakS1).AND.(i.LE.NBreakS2)) then
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      (((RBreakS2-RBreakS1)*(R_sink-tandr(n+1,2)))/
     *      (NBreakS2-NBreakS1))/(R0)
	   else if (i.GT.NBreakS2) then
	    FEM_mesh(i,n)=FEM_mesh(i-1,n)+
     *      (((1-RBreakS2)*(R_sink-tandr(n+1,2)))/(Node-NBreakS2))/(R0)
	   end if
	  end if   
5	 continue
6	continue         
c	-----------------------------------------------------------------
c	compute element lengths
	do 8 n=1,full_step
	 do 7 e=1,Element
	  h(e,n)=FEM_mesh(e+1,n)-FEM_mesh(e,n)
7	 continue
8	continue
c	-----------------------------------------------------------------
c	write output
	open(20,file='FEM_mesh.out')
	do 10 i=1,Node
	write(20,*) (FEM_mesh(i,j),j=1,full_step)
10	continue
	close (20)
c	
	if (write_file.EQ.1) then
	 open(21,file='h.out')
	 do 11 e=1,Element
	  write(21,*) (h(e,j),j=1,full_step)
11	 continue   
	 close(21)
	end if
c	-----------------------------------------------------------------
c	end of subroutine
	return
	end
c	-----------------------------------------------------------------c      (5)
c	(5)      
c	formulate linear interpolation functions on transport mesh for 
c	void ratio distribution
c
c      make the linear interpolation functions based on the
c      distribution of the void ratio made by SABRE
c
c      these functions will be used to interpolate the void ratio
c	distribution for the transport model mesh
c
c      the function takes the form: m*r+b and the SABRE_FEM matrix will
c	store m and b
c
       subroutine void_ratio_distribution(
     * number,full_step,
     * SABRE_Node,SABRE_Element,
     * Node,Element,
     * e0,eT,
     * time_tau,
     * SABRE_FEM_mesh,SABRE_h,SABRE_FEM,
     * FEM_mesh,h,
     * void_ratio_nodal,FEM)
c
c      variables
c
       implicit none       
c
       integer e,i,j,k,n
       integer number,full_step
       integer SABRE_Node,SABRE_Element
       integer Node,Element
       double precision e0,eT
       double precision time_tau((full_step+1),7)
       double precision SABRE_FEM_mesh((number*SABRE_Node),3)
       double precision SABRE_h(number*SABRE_Element)
       double precision SABRE_FEM((number*SABRE_Element),4)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision void_ratio_nodal(Node*number,5)
       double precision FEM((number*Element),4)
c
       double precision evaluation_linear
c       
       integer write_file
       common /output_file/ write_file
c
       do 2 n=1,number
        do 1 e=1,SABRE_Element
         SABRE_FEM((e+(n-1)*SABRE_Element),1)=time_tau(n,1)
         SABRE_FEM((e+(n-1)*SABRE_Element),2)=e
         if (n.EQ.1) then
          SABRE_FEM((e+(n-1)*SABRE_Element),3)=0
          SABRE_FEM((e+(n-1)*SABRE_Element),4)=eT
         else  
          SABRE_FEM((e+(n-1)*SABRE_Element),3)=
     *    (SABRE_FEM_mesh(((e+1)+(n-1)*SABRE_Node),3)-
     *    SABRE_FEM_mesh((e+(n-1)*SABRE_Node),3))*
     *    (1/(SABRE_h((e+(n-1)*SABRE_Element))))
          SABRE_FEM((e+(n-1)*SABRE_Element),4)=
     *    SABRE_FEM_mesh((e+(n-1)*SABRE_Node),3)+
     *    (SABRE_FEM_mesh((e+(n-1)*SABRE_Node),3)-
     *    SABRE_FEM_mesh(((e+1)+(n-1)*SABRE_Node),3))*
     *    ((SABRE_FEM_mesh(e+(n-1)*SABRE_Node,2))/
     *    (SABRE_h((e+(n-1)*SABRE_Element))))     
         end if   
1       continue        
2      continue
c
c      compute the value of the void ratio at each of the nodes for the
c	model mesh
c
       do 4 n=1,number
        do 3 i=1,Node
         void_ratio_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         void_ratio_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         void_ratio_nodal(i+(n-1)*Node,3)=i
         void_ratio_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
3       continue
4      continue
c
       do 6 n=1,number
        void_ratio_nodal(time_tau(n,7)+(n-1)*Node,5)=eT
        do 5 i=(time_tau(n,7)+1),Node
         void_ratio_nodal(i+(n-1)*Node,5)=eT
5       continue
6      continue
c
	j=1
	void_ratio_nodal(1,5)=e0
       do 8 n=2,number
        do 7 i=2,(SABRE_Node+1)
         k=1
         do while ((j.LE.Node).AND.(k.LE.Node))
          if (FEM_mesh(j).LT.
     *       SABRE_FEM_mesh((i-1)+(n-1)*SABRE_Node,2)) then
           void_ratio_nodal(j+(n-1)*Node,5)=
     *     evaluation_linear(SABRE_FEM((i-2)+(n-1)*SABRE_Element,3),
     *     SABRE_FEM((i-2)+(n-1)*SABRE_Element,4),
     *     FEM_mesh(j))     
           j=j+1 
          end if
          k=k+1  
         end do
7       continue
        j=1
8      continue
c
c      make the linear interpolation functions based on the
c      distribution of the void ratio on the model mesh
c
c      these functions will be assembled based on the void ratio
c	distribution
c
c      the function takes the form: m*r+b and the FEM matrix will store
c      m and b
c
       do 10 n=1,number
        do 9 e=1,Element
         FEM((e+(n-1)*Element),1)=time_tau(n,1)
         FEM((e+(n-1)*Element),2)=e
         if (n.EQ.1) then
          FEM((e+(n-1)*Element),3)=0
          FEM((e+(n-1)*Element),4)=eT
         else
          FEM((e+(n-1)*Element),3)=
     *    ((void_ratio_nodal(((e+1)+(n-1)*Node),5)-
     *    void_ratio_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          FEM((e+(n-1)*Element),4)=
     *    ((((void_ratio_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((void_ratio_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((void_ratio_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
         end if     
9       continue
10     continue         
c
c      export for graphing
c
c       open(20,file='void_ratio_nodal.out')
c       do 11 n=1,(Node*number)
c        write(20,*) (void_ratio_nodal(n,j),j=1,5)
c11     continue
c       close(20)
c
       if (write_file.EQ.1) then
        open(21,file='FEM.out')
        do 12 n=1,(number*Element)
         write(21,*) (FEM(n,j),j=1,4)
12      continue   
        close(21)
       end if
c       
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (6)
c      formulate mapping to isoparamteric space
c
c      this subroutine makes the linear functions for the isoparametric
c	space as r --> r(xi)      
c
c      the function takes the form: m*xi+b and the FEM matrix will store
c      m and b
c
       subroutine isoparametric_mapping(Node,Element,FEM_mesh,h,
     * LocalParametricMapping)
c
c      variables
c
       implicit none       
c
       integer e,j
       integer Node,Element
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision LocalParametricMapping(Element,3)
c
       integer write_file
       common /output_file/ write_file
c       
       do 1 e=1,Element
        LocalParametricMapping(e,1)=e
        LocalParametricMapping(e,2)=.5*h(e)
        LocalParametricMapping(e,3)=FEM_mesh(e)+.5*h(e)
1      continue
c
       if (write_file.EQ.1) then
        open(20,file='LPM.out')
        do 2 e=1,Element
         write(20,*) (LocalParametricMapping(e,j),j=1,3)
2       continue        
        close(20)
       end if
c       
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (7)
c      formulate shape functions
c
c      this subroutine makes the linear interpolation functions
c      used in the isoparametric space for gaussian integration
c
c      the function takes the form: m*xi+b and matrix will store
c      m and b
c
       subroutine make_shape_function(ShapeFunction,dShapeFunction)
c
c      variables
c
       implicit none       
c
       double precision ShapeFunction(2,2)
       double precision dShapeFunction(1,2)
c
       ShapeFunction(1,1)=-.5
       ShapeFunction(1,2)=.5
       ShapeFunction(2,1)=.5
       ShapeFunction(2,2)=.5
c
       dShapeFunction(1,1)=-.5
       dShapeFunction(1,2)=.5           
c
c      end of formulate shape functions subroutine
c
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (8)
c      derivative scheme
c
c      make the approximation to the exact derivative of the void ratio
c	model the derivative scheme      
c
       subroutine derivative_scheme(
     * gauss_points,quadrature,
     * number,full_step,
     * Node,Element,
     * time_tau,
     * FEM_mesh,h,
     * ShapeFunction,dShapeFunction,
     * LocalParametricMapping,
     * void_ratio_nodal, 
     * R,S,
     * d_factor,l_factor,
     * inverse_R,
     * dvoid_ratio_nodal,dFEM)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
       integer gauss_points
       double precision quadrature(gauss_points,2)
       integer number,full_step
       integer Node,Element
       double precision time_tau((full_step+1),7)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision ShapeFunction(2,2)
       double precision dShapeFunction(1,2)
       double precision LocalParametricMapping(Element,3)
       double precision void_ratio_nodal(Node*number,5)
       double precision R((2*Element),2)
       double precision S((2*Element),2)
       double precision d_factor(Node)
       double precision l_factor(Element)
       double precision inverse_R(Node,Node)
       double precision dvoid_ratio_nodal(Node*number,5)
       double precision dFEM((number*Element),4)
c
       double precision gaussian_quadrature_linear
c
       integer write_file
       common /output_file/ write_file              
c
c      assemble R matrix
c
       do 3 e=1,Element
        do 2 i=1,2
         do 1 j=1,2
          R((i+(2*(e-1))),j)=gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    0.5d0*h(e),
     *    ShapeFunction(i,1),ShapeFunction(i,2),
     *    ShapeFunction(j,1),ShapeFunction(j,2),
     *    0.0d0,1.0d0,
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3))  
1        continue
2       continue
3      continue
c
c      assemble S matrix
c
       do 6 e=1,Element
        do 5 i=1,2
         do 4 j=1,2
          S((i+(2*(e-1))),j)=gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    1.0d0,
     *    ShapeFunction(i,1),ShapeFunction(i,2),
     *    0.0d0,dShapeFunction(1,j),
     *    0.0d0,1.0d0,
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3))
4        continue
5       continue
6      continue
c
c      compute factorization of the inverse
c
       d_factor(1)=R(1,1)
c
       do 7 i=1,Element
        l_factor(i)=R(2*i,1)/d_factor(i)
        if (i.NE.Element) then 
         d_factor(i+1)=
     *   -(1.0d0)*((R(2*i,1)*R(2*i,1))/d_factor(i))+
     *   (R(2*i,2)+R((2*i)+1,1))
        else
         d_factor(i+1)=
     *   -(1.0d0)*((R(2*i,1)*R(2*i,1))/d_factor(i))+
     *   (R(2*Element,2))
        end if
7      continue
c
c      compute the inverse of R
c
c      the inverse is a full matrix of Node,Node size
c	   (with no zero elements)
c      the inverse is computed using a recursive scheme
c      first the R matrix is decomposed to an LDU form
c      for sparse symmetric matrices U=L(transpose)
c      therefore, only L and D need to be computed
c      also, because the matrix is sparse and symmetric, the inverse
c	will also be symmetric
c      this scheme only needs to calculate the lower triangular and the
c	diagonal of the inversec            
c
c      compute the Node,Node element
c
       inverse_R(Node,Node)=(d_factor(Node)**(-1))
c
c      compute the Node level row
c
       do 8 i=Element,1,-1
        inverse_R(Node,i)=((-1)*inverse_R(Node,i+1)*l_factor(i))
8      continue
c
       do 10 i=Element,1,-1
        do 9 j=i,1,-1
         if (i.EQ.j) then
          inverse_R(i,j)=
     *    (((d_factor(i))**(-1))-l_factor(i)*inverse_R(i+1,i))
         else
          inverse_R(i,j)=
     *   ((-1)*inverse_R(i,j+1)*l_factor(j))
         end if
9       continue 
10      continue
c
c      calculate the nodal values of the spatial derivative of the void
c	ratio
c
c      the value of the spatial derivative to the void ratio is computed
c	at each node
c
       do 12 n=1,number
        do 11 i=1,Node
         dvoid_ratio_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         dvoid_ratio_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         dvoid_ratio_nodal(i+(n-1)*Node,3)=i
         dvoid_ratio_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
11       continue
12      continue
c
       do 15 n=1,number
        do 14 i=1,(time_tau(n,7))
         if (i.EQ.1) then
          dvoid_ratio_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(i,1)+inverse_R(i+1,1)*S(i+1,1))*
     *    void_ratio_nodal(i+(n-1)*Node,5))+
     *    ((inverse_R(Element,1)*S((2*Element)-1,2)+inverse_R(Node,1)*
     *    S((2*Element),2))*void_ratio_nodal(Node+(n-1)*Node,5))
         else if (i.EQ.Node) then
          dvoid_ratio_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(1,1)+inverse_R(i,2)*S(2,1))*
     *    void_ratio_nodal(1+(n-1)*Node,5))+
     *    ((inverse_R(i,i-1)*S((2*Element)-1,2)+inverse_R(i,i)*
     *    S((2*Element),2))*void_ratio_nodal(i+(n-1)*Node,5))
         else
          dvoid_ratio_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(1,1)+inverse_R(i,2)*S(2,1))*
     *    void_ratio_nodal(1+(n-1)*Node,5))+
     *    ((inverse_R(Element,i)*S((2*Element)-1,2)+inverse_R(Node,i)*
     *    S((2*Element),2))*void_ratio_nodal(Node+(n-1)*Node,5))+
     *    ((inverse_R(i,i-1)*S((2*i)-3,2)+inverse_R(i,i)*(S((2*i-2),2)+
     *    S((2*i)-1,1))+inverse_R(i+1,i)*S((2*i),1))*
     *    void_ratio_nodal(i+(n-1)*Node,5))
         end if
         do 13 j=2,Element
          if ((i.LT.j).AND.(i.NE.j)) then
           dvoid_ratio_nodal(i+(n-1)*Node,5)=
     *     dvoid_ratio_nodal(i+(n-1)*Node,5)+
     *     ((inverse_R(j-1,i)*S((2*j)-3,2)+inverse_R(j,i)*(S((2*j-2),2)+
     *     S((2*j)-1,1))+inverse_R(j+1,i)*S((2*j),1))*
     *     void_ratio_nodal(j+(n-1)*Node,5))
          end if
          if ((i.GT.j).AND.(i.NE.j)) then
           dvoid_ratio_nodal(i+(n-1)*Node,5)=
     *     dvoid_ratio_nodal(i+(n-1)*Node,5)+
     *     ((inverse_R(i,j-1)*S((2*j)-3,2)+inverse_R(i,j)*(S((2*j-2),2)+
     *     S((2*j)-1,1))+inverse_R(i,j+1)*S((2*j),1))*
     *     void_ratio_nodal(j+(n-1)*Node,5))
          end if
13        continue
14       continue
15      continue
c
c      formulate linear interpolation functions for derivative void
c	ratio distribution
c
c      this subroutine makes the linear interpolation functions based on
c	the distribution of the void ratio on the model mesh
c
c      these functions will be assembled based on the derivative void
c	ratio distribution for the transport model mesh
c
c      the function takes the form: m*r+b and the dFEM matrix will store
c      m and b, just like the FEM matrix
c
       do 17 n=1,number
        do 16 e=1,Element
         dFEM((e+(n-1)*Element),1)=time_tau(n,1)
         dFEM((e+(n-1)*Element),2)=e
         if (n.EQ.1) then
          dFEM((e+(n-1)*Element),3)=0
          dFEM((e+(n-1)*Element),4)=0
         else  
          dFEM((e+(n-1)*Element),3)=
     *    (dvoid_ratio_nodal(((e+1)+(n-1)*Node),5)-
     *    dvoid_ratio_nodal((e+(n-1)*Node),5))*
     *    (1/(h((e))))
          dFEM((e+(n-1)*Element),4)=
     *    dvoid_ratio_nodal((e+(n-1)*Node),5)+
     *    (dvoid_ratio_nodal((e+(n-1)*Node),5)-
     *    dvoid_ratio_nodal(((e+1)+(n-1)*Node),5))*
     *    ((FEM_mesh(e))/
     *    (h((e))))     
         end if   
16       continue        
17      continue
c
c      export for graphing
c
c       open(20,file='dvoid_ratio_nodal.out')
c       do 18 n=1,(Node*number)
c        write(20,*) (dvoid_ratio_nodal(n,j),j=1,5)
c18     continue
c       close(20)
c
c       if (write_file.EQ.1) then
c        open(21,file='dFEM.out')
c        do 19 n=1,(number*Element)
c         write(21,*) (dFEM(n,j),j=1,4)
c19      continue   
c        close(21)
c       end if
c       
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (9)
c      evaluate values of functions at nodes and linear interpolation
c	functions
c
c      this subroutine evaluates the parameters at the nodes
c      based on the void ratio distribution
c      and the defined physical conditions
c
       subroutine nodal_values(
     * number,full_step,
     * Node,Element,
     * R0,
     * time_tau,
     * dt,
     * FEM_mesh,h,
     * fluid_porosity_physical,
     * solid_porosity_physical,
     * retardation_physical,
     * A_physical,
     * B_physical,
     * fluid_velocity_physical,
     * solid_velocity_physical,
     * peclet_physical,
     * alpha_bar_physical,
     * beta_bar_physical,
     * gamma_bar_physical,
     * theta_bar_physical,
     * D0,G,KD,DF,DS,ksi_F,ksi_S,
     * void_ratio_nodal,
     * dvoid_ratio_nodal,
     * fluid_porosity_nodal,
     * solid_porosity_nodal,
     * retardation_nodal,
     * A_nodal,
     * B_nodal,
     * fluid_velocity_nodal,
     * solid_velocity_nodal,
     * peclet_nodal,
     * alpha_bar_nodal,
     * beta_bar_nodal,
     * gamma_bar_nodal,
     * theta_bar_nodal,
     * peclet,
     * alpha_bar,
     * beta_bar,
     * gamma_bar,
     * theta_bar,
     * LocalParametricMapping)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
       integer number,full_step
       integer Node,Element
       double precision R0
       double precision time_tau((full_step+1),7)
       double precision dt(full_step,2)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision fluid_porosity_physical
       double precision solid_porosity_physical
       double precision retardation_physical
       double precision A_physical
       double precision B_physical
       double precision fluid_velocity_physical
       double precision solid_velocity_physical
       double precision peclet_physical
       double precision alpha_bar_physical
       double precision beta_bar_physical
       double precision gamma_bar_physical
       double precision theta_bar_physical
       double precision D0,G,KD,DF,DS
       double precision ksi_F,ksi_S
       double precision void_ratio_nodal(Node*number,5)
       double precision dvoid_ratio_nodal(Node*number,5)
       double precision fluid_porosity_nodal(Node*number,5)
       double precision solid_porosity_nodal(Node*number,5)
       double precision retardation_nodal(Node*number,5)
       double precision A_nodal(Node*number,5)
       double precision B_nodal(Node*number,5)
       double precision fluid_velocity_nodal(Node*number,5)
       double precision solid_velocity_nodal(Node*number,5)
       double precision peclet_nodal(Node*number,5)
       double precision alpha_bar_nodal(Node*number,5)
       double precision beta_bar_nodal(Node*number,5)
       double precision gamma_bar_nodal(Node*number,5)
       double precision theta_bar_nodal(Node*number,5)
       double precision peclet(Element*number,6)
       double precision alpha_bar(Element*number,6)
       double precision beta_bar(Element*number,6)
       double precision gamma_bar(Element*number,6)
       double precision theta_bar(Element*number,6)
       double precision LocalParametricMapping(Element,3)
c
       double precision evaluation_fluid_porosity
       double precision evaluation_solid_porosity
       double precision evaluation_retardation
       double precision evaluation_A_matrix
       double precision evaluation_B_matrix
       double precision evaluation_fluid_velocity
       double precision evaluation_fluid_velocity_tip
       double precision evaluation_solid_velocity
       double precision evaluation_peclet
       double precision evaluation_peclet_tip
       double precision evaluation_alpha_bar
       double precision evaluation_dalpha_bar       
       double precision evaluation_beta_bar
       double precision evaluation_dbeta_bar
       double precision evaluation_beta_bar_tip
       double precision evaluation_gamma_bar
       double precision evaluation_theta_bar
       double precision evaluation_theta_bar_tip
       double precision evaluation_isoparametric_m
       double precision evaluation_isoparametric_b
c
       integer write_file
       common /output_file/ write_file
c       
c      marker data
c
       do 2 n=1,number
        do 1 i=1,Node
         fluid_porosity_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         fluid_porosity_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         fluid_porosity_nodal(i+(n-1)*Node,3)=i
         fluid_porosity_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         solid_porosity_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         solid_porosity_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         solid_porosity_nodal(i+(n-1)*Node,3)=i
         solid_porosity_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         retardation_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         retardation_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         retardation_nodal(i+(n-1)*Node,3)=i
         retardation_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         A_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         A_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         A_nodal(i+(n-1)*Node,3)=i
         A_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         B_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         B_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         B_nodal(i+(n-1)*Node,3)=i
         B_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         fluid_velocity_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         fluid_velocity_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         fluid_velocity_nodal(i+(n-1)*Node,3)=i
         fluid_velocity_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         solid_velocity_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         solid_velocity_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         solid_velocity_nodal(i+(n-1)*Node,3)=i
         solid_velocity_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         peclet_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         peclet_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         peclet_nodal(i+(n-1)*Node,3)=i
         peclet_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         alpha_bar_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         alpha_bar_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         alpha_bar_nodal(i+(n-1)*Node,3)=i
         alpha_bar_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         beta_bar_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         beta_bar_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         beta_bar_nodal(i+(n-1)*Node,3)=i
         beta_bar_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         gamma_bar_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         gamma_bar_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         gamma_bar_nodal(i+(n-1)*Node,3)=i
         gamma_bar_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
         theta_bar_nodal(i+(n-1)*Node,1)=time_tau(n,1)
         theta_bar_nodal(i+(n-1)*Node,2)=time_tau(n,2)
         theta_bar_nodal(i+(n-1)*Node,3)=i
         theta_bar_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
1       continue
2      continue 
c
c      initial condition
c
       do 3 i=1,Node
        fluid_porosity_nodal(i,5)=fluid_porosity_physical
        solid_porosity_nodal(i,5)=solid_porosity_physical
        retardation_nodal(i,5)=retardation_physical
        A_nodal(i,5)=A_physical
        B_nodal(i,5)=B_physical
        fluid_velocity_nodal(i,5)=fluid_velocity_physical
        solid_velocity_nodal(i,5)=solid_velocity_physical
        peclet_nodal(i,5)=peclet_physical
        alpha_bar_nodal(i,5)=alpha_bar_physical
        beta_bar_nodal(i,5)=beta_bar_physical
        gamma_bar_nodal(i,5)=gamma_bar_physical
        theta_bar_nodal(i,5)=theta_bar_physical
3      continue  
c
c      region of bentonite extrusion
c
       do 5 n=2,number
        do 4 i=1,(time_tau(n,7))
         fluid_porosity_nodal((i+(n-1)*Node),5)=
     *   evaluation_fluid_porosity(void_ratio_nodal((i+(n-1)*Node),5))
         solid_porosity_nodal((i+(n-1)*Node),5)=
     *   evaluation_solid_porosity(void_ratio_nodal((i+(n-1)*Node),5))
         retardation_nodal((i+(n-1)*Node),5)=
     *   evaluation_retardation(void_ratio_nodal((i+(n-1)*Node),5),
     *   KD)
         A_nodal((i+(n-1)*Node),5)=
     *   evaluation_A_matrix(void_ratio_nodal((i+(n-1)*Node),5),
     *   KD,DF,DS,D0,G)
         B_nodal((i+(n-1)*Node),5)=
     *   evaluation_B_matrix(void_ratio_nodal((i+(n-1)*Node),5),
     *   KD,DF,DS)
         fluid_velocity_nodal((i+(n-1)*Node),5)=
     *   evaluation_fluid_velocity(void_ratio_nodal((i+(n-1)*Node),5),
     *   dvoid_ratio_nodal((i+(n-1)*Node),5),
     *   R0,D0,G)
         solid_velocity_nodal((i+(n-1)*Node),5)=
     *   evaluation_solid_velocity(void_ratio_nodal((i+(n-1)*Node),5),
     *   dvoid_ratio_nodal((i+(n-1)*Node),5),
     *   R0,D0,G)
         peclet_nodal((i+(n-1)*Node),5)=
     *   evaluation_peclet(void_ratio_nodal((i+(n-1)*Node),5),
     *   dvoid_ratio_nodal((i+(n-1)*Node),5),
     *   R0,DF,D0,G)
         alpha_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_alpha_bar(void_ratio_nodal((i+(n-1)*Node),5),
     *   KD)
         beta_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_beta_bar(void_ratio_nodal((i+(n-1)*Node),5),
     *   dvoid_ratio_nodal((i+(n-1)*Node),5),
     *   KD,DF,ksi_F,ksi_S,D0,G,R0)
         gamma_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_gamma_bar(void_ratio_nodal((i+(n-1)*Node),5),
     *   KD,ksi_F,ksi_S)
         theta_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_theta_bar(void_ratio_nodal((i+(n-1)*Node),5),
     *   dvoid_ratio_nodal((i+(n-1)*Node),5),
     *   KD,DF,ksi_F,ksi_S,D0,G,R0,
     *   dt((n-1),2),theta_bar_physical,FEM_mesh(i),
     *   void_ratio_nodal((i+(n-1)*Node),5),
     *   void_ratio_nodal((i+(n-2)*Node),5))     
4       continue
5      continue
c
c      region beyond extruding tip
c
       do 7 n=2,number
        do 6 i=(time_tau(n,7)+1),Node
         fluid_porosity_nodal((i+(n-1)*Node),5)=fluid_porosity_physical
         solid_porosity_nodal((i+(n-1)*Node),5)=solid_porosity_physical
         retardation_nodal((i+(n-1)*Node),5)=retardation_physical
         A_nodal((i+(n-1)*Node),5)=A_physical
         B_nodal((i+(n-1)*Node),5)=B_physical
         fluid_velocity_nodal((i+(n-1)*Node),5)=
     *   evaluation_fluid_velocity_tip(
     *   void_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   dvoid_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   FEM_mesh(i),
     *   time_tau(n,4),
     *   D0,G,R0)
         solid_velocity_nodal((i+(n-1)*Node),5)=solid_velocity_physical
         peclet_nodal((i+(n-1)*Node),5)=
     *   evaluation_peclet_tip(
     *   void_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   dvoid_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   FEM_mesh(i),
     *   time_tau(n,4),
     *   DF,D0,G,R0)
         alpha_bar_nodal((i+(n-1)*Node),5)=alpha_bar_physical
         beta_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_beta_bar_tip(
     *   void_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   dvoid_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   FEM_mesh(i),
     *   time_tau(n,4),
     *   DF,D0,G,R0,
     *   fluid_porosity_physical,
     *   A_physical)
         gamma_bar_nodal((i+(n-1)*Node),5)=gamma_bar_physical
         theta_bar_nodal((i+(n-1)*Node),5)=
     *   evaluation_theta_bar_tip(
     *   void_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   dvoid_ratio_nodal(((time_tau(n,7))+(n-1)*Node),5),
     *   FEM_mesh(i),
     *   time_tau(n,4),
     *   DF,D0,G,R0,
     *   A_physical,
     *   alpha_bar_physical,
     *   theta_bar_physical,
     *   fluid_porosity_physical)
6       continue
7      continue
c
c      linear interpolation functions
c      functions are stored as (m,b)
c      m*r+b
c
       do 9 n=1,number
        do 8 e=1,Element
         alpha_bar((e+(n-1)*Element),1)=time_tau(n,1)
         alpha_bar((e+(n-1)*Element),2)=e
         beta_bar((e+(n-1)*Element),1)=time_tau(n,1)
         beta_bar((e+(n-1)*Element),2)=e
         gamma_bar((e+(n-1)*Element),1)=time_tau(n,1)
         gamma_bar((e+(n-1)*Element),2)=e
         theta_bar((e+(n-1)*Element),1)=time_tau(n,1)
         theta_bar((e+(n-1)*Element),2)=e
         peclet((e+(n-1)*Element),1)=time_tau(n,1)
         peclet((e+(n-1)*Element),2)=e
         if (n.EQ.1) then
          alpha_bar((e+(n-1)*Element),3)=0
          alpha_bar((e+(n-1)*Element),4)=alpha_bar_physical
          beta_bar((e+(n-1)*Element),3)=0
          beta_bar((e+(n-1)*Element),4)=beta_bar_physical
          gamma_bar((e+(n-1)*Element),3)=0
          gamma_bar((e+(n-1)*Element),4)=gamma_bar_physical
          theta_bar((e+(n-1)*Element),3)=0
          theta_bar((e+(n-1)*Element),4)=theta_bar_physical
          peclet((e+(n-1)*Element),3)=0
          peclet((e+(n-1)*Element),4)=peclet_physical
         else
          alpha_bar((e+(n-1)*Element),3)=
     *    ((alpha_bar_nodal(((e+1)+(n-1)*Node),5)-
     *    alpha_bar_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          alpha_bar((e+(n-1)*Element),4)=
     *    ((((alpha_bar_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((alpha_bar_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((alpha_bar_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
          beta_bar((e+(n-1)*Element),3)=
     *    ((beta_bar_nodal(((e+1)+(n-1)*Node),5)-
     *    beta_bar_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          beta_bar((e+(n-1)*Element),4)=
     *    ((((beta_bar_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((beta_bar_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((beta_bar_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
          gamma_bar((e+(n-1)*Element),3)=
     *    ((gamma_bar_nodal(((e+1)+(n-1)*Node),5)-
     *    gamma_bar_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          gamma_bar((e+(n-1)*Element),4)=
     *    ((((gamma_bar_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((gamma_bar_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((gamma_bar_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
          theta_bar((e+(n-1)*Element),3)=
     *    ((theta_bar_nodal(((e+1)+(n-1)*Node),5)-
     *    theta_bar_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          theta_bar((e+(n-1)*Element),4)=
     *    ((((theta_bar_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((theta_bar_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((theta_bar_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
          peclet((e+(n-1)*Element),3)=
     *    ((peclet_nodal(((e+1)+(n-1)*Node),5)-
     *    peclet_nodal((e+(n-1)*Node),5))*
     *    ((1)/(h(e))))
          peclet((e+(n-1)*Element),4)=
     *    ((((peclet_nodal((e+(n-1)*Node),5))*
     *    (h(e)))+
     *    ((peclet_nodal((e+(n-1)*Node),5))*
     *    (FEM_mesh(e)))-
     *    ((peclet_nodal(((e+1)+(n-1)*Node),5))*
     *    (FEM_mesh(e))))*
     *    (((1)/(h(e)))))
         end if     
8       continue
9      continue
c   
c      isoparametric mapping
c      the linear interpolation functions are mapped into the 
c	isoparamtetric space by r --> r(xi) which is contained in 
c	LocalParametricMapping matrix
c      the coefficients form iso_m*xi+iso_b and they are stored in the 
c	matrix these coefficients will pass through to gaussian 
c	quadrature function to be integrated in the stiffness matrix
c      they are assigned to the fm,fb in the function
c
       do 11 n=1,number
        do 10 e=1,Element
          alpha_bar((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    alpha_bar((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          alpha_bar((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    alpha_bar((e+(n-1)*Element),3),
     *    alpha_bar((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
          beta_bar((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    beta_bar((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          beta_bar((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    beta_bar((e+(n-1)*Element),3),
     *    beta_bar((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
          gamma_bar((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    gamma_bar((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          gamma_bar((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    gamma_bar((e+(n-1)*Element),3),
     *    gamma_bar((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
          theta_bar((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    theta_bar((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          theta_bar((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    theta_bar((e+(n-1)*Element),3),
     *    theta_bar((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
          peclet((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    peclet((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          peclet((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    peclet((e+(n-1)*Element),3),
     *    peclet((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
10       continue
11     continue
c
c      export nodal data
c
       open(20,file='fluid_porosity_nodal.out')
c       open(21,file='solid_porosity_nodal.out')
c       open(22,file='retardation_nodal.out')
c       open(23,file='A_nodal.out')
c       open(24,file='B_nodal.out')
c       open(25,file='fluid_velocity_nodal.out')
c       open(26,file='solid_velocity_nodal.out')
       open(27,file='peclet_nodal.out')
c       open(28,file='alpha_bar_nodal.out')
c       open(29,file='beta_bar_nodal.out')
c       open(30,file='gamma_bar_nodal.out')
c       open(31,file='theta_bar_nodal.out')
c
       do 99, n=1,(number*Node)
        write(20,*) (fluid_porosity_nodal(n,j),j=1,5)
c        write(21,*) (solid_porosity_nodal(n,j),j=1,5)
c        write(22,*) (retardation_nodal(n,j),j=1,5)
c        write(23,*) (A_nodal(n,j),j=1,5)
c        write(24,*) (B_nodal(n,j),j=1,5)
c        write(25,*) (fluid_velocity_nodal(n,j),j=1,5)
c        write(26,*) (solid_velocity_nodal(n,j),j=1,5)
        write(27,*) (peclet_nodal(n,j),j=1,5)
c        write(28,*) (alpha_bar_nodal(n,j),j=1,5)
c        write(29,*) (beta_bar_nodal(n,j),j=1,5)
c        write(30,*) (gamma_bar_nodal(n,j),j=1,5)
c        write(31,*) (theta_bar_nodal(n,j),j=1,5)
99     continue        
c
       close(20)
c       close(21)
c       close(22)
c       close(23)
c       close(24)
c       close(25)
c       close(26)
       close(27)
c       close(28)
c       close(29)
c       close(30)
c       close(31)
c                                
c       if (write_file.EQ.1) then
c        open(32,file='alpha_bar.out')
c        open(33,file='beta_bar.out')
c        open(34,file='gamma_bar.out')
c        open(35,file='theta_bar.out')
c        open(36,file='peclet.out')
c        do 100 n=1,(number*Element)
c         write(32,*) (alpha_bar(n,j),j=1,6)
c         write(33,*) (beta_bar(n,j),j=1,6)
c         write(34,*) (gamma_bar(n,j),j=1,6)
c         write(35,*) (theta_bar(n,j),j=1,6)
c         write(36,*) (peclet(n,j),j=1,6)
c100     continue   
c        close(32)
c        close(33)
c        close(34)
c        close(35)
c        close(36)
c       end if
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (10)
c      compute normalized radionuclide concentration in fluid phase
c
c      this subroutine evaluates the normalized concentration of
c      the radionuclide at the nodes
c      and the linear interpolation functions for the radionuclide 
c	concentration
c
c	the solution utilizes the finite element method (Galerkin)
c	and a preconditoned conjugate gradient solver
c
c	there are several other subroutines within this subroutine
c
       subroutine radionuclide_solver(
     * number,full_step,
     * Node,Element,
     * gauss_points,
     * boundary_condition_1,
     * boundary_condition_2,
     * threshold,
     * delta,chi,epsilon,
     * numerator,denominator,
     * time_tau,
     * dt,
     * FEM_mesh,h,
     * quadrature,
     * alpha_bar,
     * beta_bar,
     * gamma_bar,
     * theta_bar,
     * LocalParametricMapping,
     * ShapeFunction,dShapeFunction,
     * mass,stiffness,
     * preconditioner,
     * preconditioned_stiffness,
     * preconditioned_force,
     * guess,residual,z,
     * N0,N1,
     * solution,solutionback,
     * nextstep,
     * ndot,ndotback,
     * radionuclide_nodal,
     * radionuclide_FEM)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
       integer number,full_step
       integer Node,Element
	integer gauss_points
       double precision boundary_condition_1
	double precision boundary_condition_2
       double precision threshold
	double precision delta,chi,epsilon
	double precision numerator,denominator
       double precision time_tau((full_step+1),7)
       double precision dt(full_step,2)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision quadrature(gauss_points,2)
       double precision alpha_bar(Element*number,6)
       double precision beta_bar(Element*number,6)
       double precision gamma_bar(Element*number,6)
       double precision theta_bar(Element*number,6)
       double precision LocalParametricMapping(Element,3)
       double precision ShapeFunction(2,2)
       double precision dShapeFunction(1,2)
       double precision mass(2*Element,2)
       double precision stiffness(2*Element,2)
       double precision preconditioner(2*Element,2)
       double precision preconditioned_stiffness(2*Element,2)
       double precision preconditioned_force(Node)
       double precision guess(Node)
       double precision residual(Node)
       double precision z(Node)
       double precision N0(Node)
       double precision N1(Node-2)
       double precision solution(Node)
       double precision solutionback(Node)
       double precision nextstep(Node)
       double precision ndot(Node)
       double precision ndotback(Node)
       double precision radionuclide_nodal(full_step*Node,5)
       double precision radionuclide_FEM(Element*full_step,6)
c
       double precision gaussian_quadrature_linear
       double precision evaluation_isoparametric_m
       double precision evaluation_isoparametric_b
c
       integer write_file
       common /output_file/ write_file
c
c	initialize boundary conditions
	N0(1)=boundary_condition_1
       N0(Node)=boundary_condition_2
c
	nextstep(1)=boundary_condition_1
	nextstep(Node)=boundary_condition_2
c
c      first two time steps
c      backward euler for time integration
c
c
       do 10 n=2,3
       write(6,*) 'main loop',n
c
c      (i)
c      assemble local mass matrix and local stiffness matrix
        call local_FEM(
     *  n,
     *  number,full_step,
     *  Node,Element,
     *  gauss_points,
     *  h,
     *  quadrature,
     *  alpha_bar,
     *  beta_bar,
     *  gamma_bar,
     *  theta_bar,
     *  LocalParametricMapping,
     *  ShapeFunction,dShapeFunction,
     *  mass,stiffness)
c
c      assemble the preconditoner
c
        do 1 e=1,(2*Element)
         preconditioner(e,1)=
     *   (1/dt(n-1,2))*mass(e,1)+stiffness(e,1)
         preconditioner(e,2)=
     *   (1/dt(n-1,2))*mass(e,2)+stiffness(e,2)
1       continue
c
c      assemble global preconditioned stiffness matrix and global
c	preconditioned force vector
c      this is not a subroutine because the matrix assembly is different
c	for n>=4
c      
        do 2 e=1,(2*Element)
         preconditioned_stiffness(e,1)=preconditioner(e,1)
         preconditioned_stiffness(e,2)=preconditioner(e,2)
2       continue
c
c      first three elements
        preconditioned_stiffness(1,1)=
     *  preconditioned_stiffness(1,1)/
     *  (preconditioner(1,1)**(.5)*preconditioner(1,1)**(.5))
        preconditioned_stiffness(1,2)=
     *  preconditioned_stiffness(1,2)/
     *  (preconditioner(1,1)**(.5)*(preconditioner(2,2)+
     *  preconditioner(3,1))**(.5))
        preconditioned_stiffness(2,1)=
     *  preconditioned_stiffness(2,1)/
     *  (preconditioner(1,1)**(.5)*
     *  (preconditioner(2,2)+preconditioner(3,1))**(.5))
c 
c      last three elements
        preconditioned_stiffness(2*Element-1,2)=
     *  preconditioned_stiffness(2*Element-1,2)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  (preconditioner(2*Element-2,2)+
     *  preconditioner(2*Element-1,1))**(.5))
        preconditioned_stiffness(2*Element,1)=
     *  preconditioned_stiffness(2*Element,1)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  (preconditioner(2*Element-2,2)+
     *  preconditioner(2*Element-1,1))**(.5))
        preconditioned_stiffness(2*Element,2)=
     *  preconditioned_stiffness(2*Element,2)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  preconditioner(2*Element,2)**(.5))
c
c      diagonals split
        do 3 e=2,Element
         preconditioned_stiffness(2*e-2,2)=
     *   preconditioned_stiffness(2*e-2,2)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
         preconditioned_stiffness(2*e-1,1)=
     *   preconditioned_stiffness(2*e-1,1)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
3       continue
c
c      upper/lower band
        do 4 e=2,(Element-1)
         preconditioned_stiffness(2*e-1,2)=
     *   preconditioned_stiffness(2*e-1,2)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e,2)+preconditioner(2*e+1,1))**(.5))
         preconditioned_stiffness(2*e,1)=
     *   preconditioned_stiffness(2*e,1)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e,2)+preconditioner(2*e+1,1))**(.5))
4       continue
c
c      representative preconditioned force vector
        preconditioned_force(1)=
     *  ((1/dt(n-1,2))*mass(1,1)*nextstep(1)+
     *  (1/dt(n-1,2))*mass(1,2)*nextstep(2))/(preconditioner(1,1)**(.5))
        preconditioned_force(Node)=
     *  ((1/dt(n-1,2))*mass(2*Element,1)*nextstep(Node-1)+
     *  (1/dt(n-1,2))*mass(2*Element,2)*nextstep(Node))/
     *  (preconditioner(2*Element,2)**(.5))
c
        do 5 e=2,Element
         preconditioned_force(e)=
     *   ((1/dt(n-1,2))*mass(2*e-2,1)*nextstep(e-1)+
     *   ((1/dt(n-1,2))*mass(2*e-2,2)+(1/dt(n-1,2))*
     *   mass(2*e-1,1))*nextstep(e)+
     *   (1/dt(n-1,2))*mass(2*e-1,2)*nextstep(e+1))/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
5       continue
c
c      (ii)
c      execute preconditioned conjugate gradient scheme
        call PCG_solver(
     *  n,
     *  number,full_step,
     *  Node,Element,
     *  threshold,
     *  delta,chi,epsilon,
     *  numerator,denominator,
     *  preconditioner,
     *  preconditioned_stiffness,
     *  preconditioned_force,
     *  guess,residual,z,
     *  nextstep)
c
c      transform the solution back to the real space
c
c       solution(1)=guess(1)*
c    *  ((preconditioner(1,1))**(-.5))
c       solution(Node)=guess(Node)*
c    *  ((preconditioner(2*Element,2))**(-.5))
c
        solution(1)=N0(1)
        solution(Node)=N0(Node)
c
        do 6 i=2,(Node-1)
         solution(i)=guess(i)*
     *   ((preconditioner(2*i-2,2)+
     *   preconditioner(2*i-1,1))**(-.5))
6       continue
c
        do 7 i=1,Node
         ndot(i)=(1/dt(n-1,2))*
     *   (solution(i)-nextstep(i))
7       continue
c
        do 8 i=1,Node
         nextstep(i)=solution(i)
         ndotback(i)=ndot(i)
8       continue
c
        do 9 i=1,Node
         radionuclide_nodal(i+(n-2)*Node,1)=
     *   time_tau(n,1)
         radionuclide_nodal(i+(n-2)*Node,2)=
     *   time_tau(n,2)
         radionuclide_nodal(i+(n-2)*Node,3)=
     *   i
         radionuclide_nodal(i+(n-2)*Node,4)=
     *   FEM_mesh(i)
         radionuclide_nodal(i+(n-2)*Node,5)=
     *   solution(i)
9       continue
c        
10     continue
c
c      remaining time steps
c      implicit trapezoid for time integration
c
       do 20 n=4,number
       write(6,*) 'main loop',n
c
c      (i)
c      assemble local mass matrix and local stiffness matrix
        call local_FEM(
     *  n,
     *  number,full_step,
     *  Node,Element,
     *  gauss_points,
     *  h,
     *  quadrature,
     *  alpha_bar,
     *  beta_bar,
     *  gamma_bar,
     *  theta_bar,
     *  LocalParametricMapping,
     *  ShapeFunction,dShapeFunction,
     *  mass,stiffness)
c
c      assemble the preconditoner
c
        do 11 e=1,(2*Element)
         preconditioner(e,1)=
     *   (2/dt(n-1,2))*mass(e,1)+stiffness(e,1)
         preconditioner(e,2)=
     *   (2/dt(n-1,2))*mass(e,2)+stiffness(e,2)
11      continue
c
c      assemble global preconditioned stiffness matrix and global preconditioned force vector
c      this is not a subroutine because the matrix assembly is different for n >= 4
c      
        do 12 e=1,(2*Element)
         preconditioned_stiffness(e,1)=preconditioner(e,1)
         preconditioned_stiffness(e,2)=preconditioner(e,2)
12      continue
c
c      first three elements
        preconditioned_stiffness(1,1)=
     *  preconditioned_stiffness(1,1)/
     *  (preconditioner(1,1)**(.5)*preconditioner(1,1)**(.5))
        preconditioned_stiffness(1,2)=
     *  preconditioned_stiffness(1,2)/
     *  (preconditioner(1,1)**(.5)*(preconditioner(2,2)+
     *  preconditioner(3,1))**(.5))
        preconditioned_stiffness(2,1)=
     *  preconditioned_stiffness(2,1)/
     *  (preconditioner(1,1)**(.5)*
     *  (preconditioner(2,2)+preconditioner(3,1))**(.5))
c 
c      last three elements
        preconditioned_stiffness(2*Element-1,2)=
     *  preconditioned_stiffness(2*Element-1,2)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  (preconditioner(2*Element-2,2)+
     *  preconditioner(2*Element-1,1))**(.5))
        preconditioned_stiffness(2*Element,1)=
     *  preconditioned_stiffness(2*Element,1)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  (preconditioner(2*Element-2,2)+
     *  preconditioner(2*Element-1,1))**(.5))
        preconditioned_stiffness(2*Element,2)=
     *  preconditioned_stiffness(2*Element,2)/
     *  (preconditioner(2*Element,2)**(.5)*
     *  preconditioner(2*Element,2)**(.5))
c
c      diagonals split
        do 13 e=2,Element
         preconditioned_stiffness(2*e-2,2)=
     *   preconditioned_stiffness(2*e-2,2)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
         preconditioned_stiffness(2*e-1,1)=
     *   preconditioned_stiffness(2*e-1,1)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
13      continue
c
c      upper/lower band
        do 14 e=2,(Element-1)
         preconditioned_stiffness(2*e-1,2)=
     *   preconditioned_stiffness(2*e-1,2)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e,2)+preconditioner(2*e+1,1))**(.5))
         preconditioned_stiffness(2*e,1)=
     *   preconditioned_stiffness(2*e,1)/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5)*
     *   (preconditioner(2*e,2)+preconditioner(2*e+1,1))**(.5))
14      continue
c
c      representative preconditioned force vector
        preconditioned_force(1)=
     *  (mass(1,1)*((2/dt(n-1,2))*nextstep(1)+ndotback(1))+
     *  mass(1,2)*((2/dt(n-1,2))*nextstep(2)+ndotback(2)))/
     *  (preconditioner(1,1)**(.5))
        preconditioned_force(Node)=
     *  (mass(2*Element,1)*((2/dt(n-1,2))*nextstep(Node-1)+
     *  ndotback(Node-1))+mass(2*Element,2)*((2/dt(n-1,2))*
     *  nextstep(Node)+ndotback(Node)))/
     *  (preconditioner(2*Element,2)**(.5))
c
        do 15 e=2,Element
         preconditioned_force(e)=
     *   (mass(2*e-2,1)*((2/dt(n-1,2))*nextstep(e-1)+
     *   ndotback(e-1))+(mass(2*e-2,2)+mass(2*e-1,1))*
     *   ((2/dt(n-1,2))*nextstep(e)+ndotback(e))+
     *   mass(2*e-1,2)*((2/dt(n-1,2))*nextstep(e+1)+ndotback(e+1)))/
     *   ((preconditioner(2*e-2,2)+preconditioner(2*e-1,1))**(.5))
15      continue
c
c      (ii)
c      execute preconditioned conjugate gradient scheme
        call PCG_solver(
     *  n,
     *  number,full_step,
     *  Node,Element,
     *  threshold,
     *  delta,chi,epsilon,
     *  numerator,denominator,
     *  preconditioner,
     *  preconditioned_stiffness,
     *  preconditioned_force,
     *  guess,residual,z,
     *  nextstep)
c
c      transform the solution back to the real space
c
c       solution(1)=guess(1)*
c     * ((preconditioner(1,1))**(-.5))
c       solution(Node)=guess(Node)*
c     * ((preconditioner(2*Element,2))**(-.5))
c
        solution(1)=N0(1)
        solution(Node)=N0(Node)
c
        do 16 i=2,(Node-1)
         solution(i)=guess(i)*
     *   ((preconditioner(2*i-2,2)+
     *   preconditioner(2*i-1,1))**(-.5))
16      continue
c
        do 17 i=1,Node
         ndot(i)=(2/dt(n-1,2))*
     *   (solution(i)-nextstep(i))-ndotback(i)
17      continue
c
        do 18 i=1,Node
         nextstep(i)=solution(i)
         ndotback(i)=ndot(i)
18      continue
c
        do 19 i=1,Node
         radionuclide_nodal(i+(n-2)*Node,1)=
     *   time_tau(n,1)
         radionuclide_nodal(i+(n-2)*Node,2)=
     *   time_tau(n,2)
         radionuclide_nodal(i+(n-2)*Node,3)=
     *   i
         radionuclide_nodal(i+(n-2)*Node,4)=
     *   FEM_mesh(i)
         radionuclide_nodal(i+(n-2)*Node,5)=
     *   solution(i)
19      continue
c        
20     continue
c
c      make the linear interpolation functions based on the
c      distribution of the radionuclide on the model mesh
c
c      these functions will be assembled based on the void ratio
c	distribution
c
c      the function takes the form: m*r+b and the matrix will store
c      m and b
c
       do 22 n=1,full_step
        do 21 e=1,Element
         radionuclide_FEM((e+(n-1)*Element),1)=time_tau(n+1,1)
         radionuclide_FEM((e+(n-1)*Element),2)=e
         radionuclide_FEM((e+(n-1)*Element),3)=
     *   ((radionuclide_nodal(((e+1)+(n-1)*Node),5)-
     *   radionuclide_nodal((e+(n-1)*Node),5))*
     *   ((1)/(h(e))))
         radionuclide_FEM((e+(n-1)*Element),4)=
     *   ((((radionuclide_nodal((e+(n-1)*Node),5))*
     *   (h(e)))+
     *   ((radionuclide_nodal((e+(n-1)*Node),5))*
     *   (FEM_mesh(e)))-
     *   ((radionuclide_nodal(((e+1)+(n-1)*Node),5))*
     *   (FEM_mesh(e))))*
     *   (((1)/(h(e)))))
21       continue
22     continue         
c
c      isoparametric mapping
c      the linear interpolation functions are mapped into the
c	isoparamtetric space by r --> r(xi) which is contained in
c	LocalParametricMapping matrix
c      the coefficients form iso_m*xi+iso_b and they are stored in the
c	matrix
c      these coefficients will pass through to gaussian quadrature
c	function to
c      be integrated in the stiffness matrix
c      they are assigned to the fm,fb in the function
c
       do 24 n=1,full_step
        do 23 e=1,Element
          radionuclide_FEM((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    radionuclide_FEM((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          radionuclide_FEM((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    radionuclide_FEM((e+(n-1)*Element),3),
     *    radionuclide_FEM((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
23       continue
24     continue
c
c       export nodal data
c
	write(6,*) 'output'
       open(20,file='radionuclide_nodal.out')
       do 99, n=1,(full_step*Node)
        write(20,*) (radionuclide_nodal(n,j),j=1,5)
99     continue        
       close(20)
c                                
c        if (write_file.EQ.1) then
         open(30,file='radionuclide_FEM.out')
         do 100 n=1,(full_step*Element)
          write(30,*) (radionuclide_FEM(n,j),j=1,6)
100      continue   
         close(30)
c         if (n.EQ.2) then
c          open(31,file='f2.out')
c          do 101 i=1,(Node)
c           write(31,*) (preconditioned_force(i))
c101        continue
c          close(31)
c         end if
c         if (n.EQ.3) then
c          open(31,file='f3.out')
c          do 102 i=1,(Node)
c           write(31,*) (preconditioned_force(i))
c102        continue
c          close(31)
c         end if
c        end if
c
c      end of subroutine
c
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (11)
c      compute normalized radionuclide release rate
c
c      this subroutine evaluates the normalized release rate of
c      the radionuclide at the nodes
c
       subroutine release_rate(
     * number,full_step,
     * Node,Element,
     * D_prime,R0,
     * zero_flag,
     * time_tau,
     * FEM_mesh,h,
     * LocalParametricMapping,
     * fluid_porosity_nodal,
     * peclet_nodal,
     * S,
     * inverse_R,
     * radionuclide_nodal,
     * radionuclide_FEM,
     * dradionuclide_nodal,
     * dradionuclide_FEM,
     * release_rate_nodal,
     * release_rate_FEM,
     * release_rate_graph,
     * release_rate_raw,
     * release_rate_tip,
     * dflag)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
       integer number,full_step
       integer Node,Element
       double precision D_prime,R0
	double precision zero_flag
	double precision time_tau((full_step+1),7)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision LocalParametricMapping(Element,3)
       double precision fluid_porosity_nodal(Node*number,5)
       double precision peclet_nodal(Node*number,5)
       double precision S((2*Element),2)
       double precision inverse_R(Node,Node)
       double precision radionuclide_nodal(full_step*Node,5)
       double precision radionuclide_FEM(Element*full_step,6)
       double precision dradionuclide_nodal(full_step*Node,5)
       double precision dradionuclide_FEM(Element*full_step,6)
       double precision release_rate_nodal(Node*full_step,5)
       double precision release_rate_FEM(Element*full_step,6)
       double precision release_rate_graph(full_step,(Node+1))
       double precision release_rate_raw(Node,(full_step+1))
       double precision release_rate_tip(full_step,3)      
       double precision dflag(full_step,4)
c
       double precision evaluation_isoparametric_m
       double precision evaluation_isoparametric_b
c
       integer write_file
       common /output_file/ write_file
c
c      flag the zero concentration
c
       do 1 n=1,full_step
        dflag(n,1)=time_tau(n+1,1)
1      continue
c
       do 2 n=1,full_step
        i=1
        do while ((radionuclide_nodal(i+(n-1)*Node,5).GE.zero_flag)
     *           .AND.(i.LE.(Node-1)))
         if ((radionuclide_nodal(i+(n-1)*Node,5).GE.zero_flag)
     *      .AND.
     *      (radionuclide_nodal((i+1)+(n-1)*Node,5).LT.zero_flag)) then
          dflag(n,2)=FEM_mesh(i)
          dflag(n,3)=FEM_mesh(i+1)
          dflag(n,4)=i+1
         end if
         i=i+1
        end do
2      continue
c
c      calculate the derivatives of the radionuclide at the nodes
c
       do 4 n=1,full_step
        do 3 i=1,Node
         dradionuclide_nodal(i+(n-1)*Node,1)=time_tau(n+1,1)
         dradionuclide_nodal(i+(n-1)*Node,2)=time_tau(n+1,2)
         dradionuclide_nodal(i+(n-1)*Node,3)=i
         dradionuclide_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
3       continue
4      continue
c
       do 7 n=1,number
        do 6 i=1,(dflag(n,4))
         if (i.EQ.1) then
          dradionuclide_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(i,1)+inverse_R(i+1,1)*S(i+1,1))*
     *    radionuclide_nodal(i+(n-1)*Node,5))+
     *    ((inverse_R(Element,1)*S((2*Element)-1,2)+inverse_R(Node,1)*
     *    S((2*Element),2))*radionuclide_nodal(Node+(n-1)*Node,5))
         else if (i.EQ.Node) then
          dradionuclide_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(1,1)+inverse_R(i,2)*S(2,1))*
     *    radionuclide_nodal(1+(n-1)*Node,5))+
     *    ((inverse_R(i,i-1)*S((2*Element)-1,2)+inverse_R(i,i)*
     *    S((2*Element),2))*radionuclide_nodal(i+(n-1)*Node,5))
         else
          dradionuclide_nodal(i+(n-1)*Node,5)=
     *    ((inverse_R(i,1)*S(1,1)+inverse_R(i,2)*S(2,1))*
     *    radionuclide_nodal(1+(n-1)*Node,5))+
     *    ((inverse_R(Element,i)*S((2*Element)-1,2)+inverse_R(Node,i)*
     *    S((2*Element),2))*radionuclide_nodal(Node+(n-1)*Node,5))+
     *    ((inverse_R(i,i-1)*S((2*i)-3,2)+inverse_R(i,i)*(S((2*i-2),2)+
     *    S((2*i)-1,1))+inverse_R(i+1,i)*S((2*i),1))*
     *    radionuclide_nodal(i+(n-1)*Node,5))
         end if
         do 5 j=2,Element
          if ((i.LT.j).AND.(i.NE.j)) then
           dradionuclide_nodal(i+(n-1)*Node,5)=
     *     dradionuclide_nodal(i+(n-1)*Node,5)+
     *     ((inverse_R(j-1,i)*S((2*j)-3,2)+inverse_R(j,i)*(S((2*j-2),2)+
     *     S((2*j)-1,1))+inverse_R(j+1,i)*S((2*j),1))*
     *     radionuclide_nodal(j+(n-1)*Node,5))
          end if
          if ((i.GT.j).AND.(i.NE.j)) then
           dradionuclide_nodal(i+(n-1)*Node,5)=
     *     dradionuclide_nodal(i+(n-1)*Node,5)+
     *     ((inverse_R(i,j-1)*S((2*j)-3,2)+inverse_R(i,j)*(S((2*j-2),2)+
     *     S((2*j)-1,1))+inverse_R(i,j+1)*S((2*j),1))*
     *     radionuclide_nodal(j+(n-1)*Node,5))
          end if
5        continue
6       continue
7      continue
c
c      compute release rate at the nodes
c
       do 9 n=1,full_step
        do 8 i=1,Node
         release_rate_nodal(i+(n-1)*Node,1)=
     *   time_tau(n+1,1)
         release_rate_nodal(i+(n-1)*Node,2)=
     *   time_tau(n+1,2)
         release_rate_nodal(i+(n-1)*Node,3)=
     *   i
         release_rate_nodal(i+(n-1)*Node,4)=
     *   FEM_mesh(i)
         release_rate_nodal(i+(n-1)*Node,5)=
     *   ((-1)*(fluid_porosity_nodal(i+(n)*Node,5))*
     *   (dradionuclide_nodal(i+(n-1)*Node,5)))+
     *   ((fluid_porosity_nodal(i+(n)*Node,5))*
     *   (peclet_nodal(i+(n)*Node,5))*
     *   (radionuclide_nodal(i+(n-1)*Node,5)))
8       continue
9      continue
c
c      make the linear interpolation functions based on the
c      distribution of the radionuclide derivative on the model mesh
c
c      these functions will be assembled based on the void ratio
c	distribution
c
c      the function takes the form: m*r+b and the matrix will store
c      m and b
c
       do 11 n=1,full_step
        do 10 e=1,Element
         dradionuclide_FEM((e+(n-1)*Element),1)=time_tau(n+1,1)
         dradionuclide_FEM((e+(n-1)*Element),2)=e
         release_rate_FEM((e+(n-1)*Element),1)=time_tau(n+1,1)
         release_rate_FEM((e+(n-1)*Element),2)=e         
c
         dradionuclide_FEM((e+(n-1)*Element),3)=
     *   ((dradionuclide_nodal(((e+1)+(n-1)*Node),5)-
     *   dradionuclide_nodal((e+(n-1)*Node),5))*
     *   ((1)/(h(e))))
         dradionuclide_FEM((e+(n-1)*Element),4)=
     *   ((((dradionuclide_nodal((e+(n-1)*Node),5))*
     *   (h(e)))+
     *   ((dradionuclide_nodal((e+(n-1)*Node),5))*
     *   (FEM_mesh(e)))-
     *   ((dradionuclide_nodal(((e+1)+(n-1)*Node),5))*
     *   (FEM_mesh(e))))*
     *   (((1)/(h(e)))))
c
         release_rate_FEM((e+(n-1)*Element),3)=
     *   ((release_rate_nodal(((e+1)+(n-1)*Node),5)-
     *   release_rate_nodal((e+(n-1)*Node),5))*
     *   ((1)/(h(e))))
         release_rate_FEM((e+(n-1)*Element),4)=
     *   ((((release_rate_nodal((e+(n-1)*Node),5))*
     *   (h(e)))+
     *   ((release_rate_nodal((e+(n-1)*Node),5))*
     *   (FEM_mesh(e)))-
     *   ((release_rate_nodal(((e+1)+(n-1)*Node),5))*
     *   (FEM_mesh(e))))*
     *   (((1)/(h(e)))))
10       continue
11     continue         
c
c      isoparametric mapping
c      the linear interpolation functions are mapped into the
c	isoparamtetric space by r --> r(xi) which is contained in
c	LocalParametricMapping matrix the coefficients form 
c	iso_m*xi+iso_b and they are stored in the matrix
c      these coefficients will pass through to gaussian quadrature
c	function to be integrated in the stiffness matrix
c      they are assigned to the fm,fb in the function
c
       do 13 n=1,full_step
        do 12 e=1,Element
          dradionuclide_FEM((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    dradionuclide_FEM((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          dradionuclide_FEM((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    dradionuclide_FEM((e+(n-1)*Element),3),
     *    dradionuclide_FEM((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))
c
          release_rate_FEM((e+(n-1)*Element),5)=
     *    evaluation_isoparametric_m(
     *    release_rate_FEM((e+(n-1)*Element),3),
     *    LocalParametricMapping(e,2))
          release_rate_FEM((e+(n-1)*Element),6)=
     *    evaluation_isoparametric_b(
     *    release_rate_FEM((e+(n-1)*Element),3),
     *    release_rate_FEM((e+(n-1)*Element),4),
     *    LocalParametricMapping(e,3))     
12       continue
13     continue
c
c	assemble release rate at the tip of extrusion
c
	do 14 i=1,Node
  	 release_rate_raw(i,1)=i 
14	continue
c
	do 16 n=1,full_step
 	 do 15 i=1,Node
  	  release_rate_raw(i,n+1)=release_rate_nodal((n-1)*Node+i,5)
15 	 continue
16	continue
c
	do 17 n=1,full_step
 	 release_rate_graph(n,1)=time_tau(n+1,1)
17	continue
c
	do 19 i=1,Node
 	 do 18 n=2,(full_step+1)
  	  release_rate_graph((n-1),(2+(i-1)))=
     *    release_rate_raw((1+(i-1)),n)
18 	 continue
19	continue
c
	do 20 n=1,full_step
 	 release_rate_tip(n,1)=time_tau(n+1,1)
 	 release_rate_tip(n,2)=release_rate_graph(n,(time_tau(n+1,7)+1))
 	 release_rate_tip(n,3)=release_rate_tip(n,2)*(D_prime/R0)
20	continue
c
c      export nodal data
c
c       open(20,file='dradionuclide_nodal.out')
c       do 90 n=1,(Node*full_step)
c        write(20,*) (dradionuclide_nodal(n,j),j=1,5)
c90     continue
c       close(20)
c
       open(21,file='release_rate_nodal.out')
       do 91 n=1,(Node*full_step)
        write(21,*) (release_rate_nodal(n,j),j=1,5)
91     continue
       close(21)       
c
       open(22,file='release_rate_tip.out')
       do 92 n=1,full_step
        write(22,*) (release_rate_tip(n,j),j=1,2)
92     continue
       close(22)
c
       if (write_file.EQ.1) then
        open(30,file='zero_flag.out')
        do 100 n=1,full_step
         write(30,*) (dflag(n,j),j=1,4)
100     continue   
        close(30)
        open(31,file='dradionuclide_FEM.out')
        open(32,file='release_rate_FEM.out')         
        do 101 n=1,(full_step*Element)
         write(31,*) (dradionuclide_FEM(n,j),j=1,6)
         write(32,*) (release_rate_FEM(n,j),j=1,6)
101     continue
        close(31)
        close(32)   
       end if
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (12)
c      compute energy norm DNP
c
c      this subroutine evaluates the energy norm for n=2
c	(first time step)
c
c	subroutine evaluate_energy_norm(
c    * number,full_step,
c    * Node,Element,
c    * gauss_points,
c    * quadrature,
c    * time_tau,
c    * FEM_mesh,h,
c    * LocalParametricMapping,
c    * gamma_bar,
c    * dradionuclide_FEM,
c    * energy_norm_element,
c    * energy_norm)
c
c      variables
c
c      implicit none       
c
c      integer e,i,j,n
c      integer number,full_step
c      integer Node,Element
c      integer gauss_points
c      double precision quadrature(gauss_points,2)
c	double precision time_tau((full_step+1),7)
c      double precision FEM_mesh(Node)
c      double precision h(Element)
c      double precision LocalParametricMapping(Element,3)
c      double precision gamma_bar(Element*number,6)
c      double precision dradionuclide_FEM(Element*full_step,6)
c      double precision energy_norm_element(Element,5)
c      double precision energy_norm(1,3)
c
c      double precision sum
c
c      double precision gaussian_quadrature_linear
c
c      integer write_file
c      common /output_file/ write_file
c
c      integrate over each element
c
c      do 1 e=1,Element
c       energy_norm_element(e,1)=time_tau(2,1)
c       energy_norm_element(e,2)=time_tau(2,2)
c       energy_norm_element(e,3)=FEM_mesh(e)+0.5d0*h(e)
c       energy_norm_element(e,4)=e
c       energy_norm_element(e,5)=
c    *  gaussian_quadrature_linear
c    *  (gauss_points,
c    *  quadrature,     
c    *  2.0d0/h(e),
c    *  dradionuclide_FEM(e,5),dradionuclide_FEM(e,6),
c    *  dradionuclide_FEM(e,5),dradionuclide_FEM(e,6),
c    *  gamma_bar(e+(1)*Element,5),gamma_bar(e+(1)*Element,6),
c    *  LocalParametricMapping(e,2),LocalParametricMapping(e,3))
c1     continue          
c
c      add the integrations from each element
c
c      energy_norm(1,1)=time_tau(2,1)
c      energy_norm(1,2)=time_tau(2,2)
c
c      sum=0.0d0
c
c      do 2 e=1,Element
c       sum=
c    *  sum+energy_norm_element(e,5)
c2     continue
c
c      energy_norm(1,3)=(sum)**(.5)     
c
c      export data
c
c      open(20,file='energy_norm.out')
c      write(20,*) (energy_norm(1,j),j=1,3)
c      close(20)
c
c       if (write_file.EQ.1) then
c        open(30,file='energy_norm_element.out')
c        do 100 e=1,Element
c         write(30,*) (energy_norm_element(e,j),j=1,5)
c100      continue   
c        close(30)
c       end if
c
c      end subroutine
c
c      return
c      end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (14)
c      compute mass ratio
c
c      this subroutine evaluates the ratio of radionuclide mass in the
c	region of bentonite extrusion
c      to the total mass at the specific time step
c
       subroutine mass_ratio(
     * number,full_step,
     * Node,Element,
     * gauss_points,
     * quadrature,
     * time_tau,
     * FEM_mesh,h,
     * LocalParametricMapping,
     * alpha_bar,
     * radionuclide_FEM,
     * delta_ratio_element,
     * delta_ratio)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
       integer number,full_step
       integer Node,Element
       integer gauss_points
       double precision quadrature(gauss_points,2)
       double precision time_tau((full_step+1),7)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision LocalParametricMapping(Element,3)
       double precision alpha_bar(Element*number,6)
       double precision radionuclide_FEM(Element*full_step,6)
       double precision delta_ratio_element(full_step*Element,5)
       double precision delta_ratio(full_step,5)
c
       double precision sum
c
       double precision gaussian_quadrature_linear
c
       integer write_file
       common /output_file/ write_file
c
c      integrate over each element
c
       do 2 n=1,full_step
        do 1 e=1,Element
         delta_ratio_element(e+(n-1)*Element,1)=time_tau(n+1,1)
         delta_ratio_element(e+(n-1)*Element,2)=time_tau(n+1,2)
         delta_ratio_element(e+(n-1)*Element,3)=FEM_mesh(e)+0.5d0*h(e)
         delta_ratio_element(e+(n-1)*Element,4)=e
         delta_ratio_element(e+(n-1)*Element,5)=
     *   gaussian_quadrature_linear
     *   (gauss_points,
     *   quadrature,     
     *   0.5d0*h(e),
     *   0.0d0,1.0d0,
     *   radionuclide_FEM(e+(n-1)*Element,5),
     *   radionuclide_FEM(e+(n-1)*Element,6),
     *   alpha_bar(e+(n)*Element,5),alpha_bar(e+(n)*Element,6),
     *   LocalParametricMapping(e,2),LocalParametricMapping(e,3))
1       continue
2      continue
c
c      add the integrations from each element
c
       do 3 n=1,full_step
        delta_ratio(n,1)=time_tau(n+1,1)
        delta_ratio(n,2)=time_tau(n+1,2)
3      continue       
c
       sum=0.0d0
c
       do 5 n=1,full_step
        do 4 e=1,(time_tau(n+1,7)-1)
         sum=
     *   sum+delta_ratio_element(e+(n-1)*Element,5)
4       continue
        delta_ratio(n,3)=sum
        sum=0.0d0
5      continue
c
       sum=0.0d0
c
       do 7 n=1,full_step
        do 6 e=1,Element
         sum=
     *   sum+delta_ratio_element(e+(n-1)*Element,5)
6       continue
        delta_ratio(n,4)=sum
        sum=0.0d0
7      continue
c
       do 8 n=1,full_step
        delta_ratio(n,5)=delta_ratio(n,3)/delta_ratio(n,4)
8      continue
c
c      export data
c
       open(20,file='delta_ratio.out')
       do 90 n=1,full_step
        write(20,*) (delta_ratio(n,j),j=1,5)
90     continue
       close(20)

        if (write_file.EQ.1) then
         open(30,file='delta_ratio_element.out')
         do 100 n=1,(full_step*Element)
          write(30,*) (delta_ratio_element(n,j),j=1,5)
100      continue   
         close(30)
        end if
c
c      end subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (15)
c      compute residence time
c
c      this subroutine evaluates the residence time of the radionuclide
c	in the region of bentonite extrusion
c
       subroutine residence_time(
     * number,full_step,
     * Node,Element,
     * gauss_points,
     * quadrature,
     * R0,D_prime,
     * time_tau,
     * FEM_mesh,h,
     * LocalParametricMapping,
     * release_rate_tip,
     * release_rate_FEM,
     * delta_ratio,
     * eta_ratio_element,
     * eta_ratio)
c
c      variables
c
       implicit none       
c
       integer e,i,j,n
	double precision pi
	parameter(pi=3.14159265358979)
       integer number,full_step
       integer Node,Element
       integer gauss_points
       double precision quadrature(gauss_points,2)
       double precision R0,D_prime
       double precision time_tau((full_step+1),7)
       double precision FEM_mesh(Node)
       double precision h(Element)
       double precision LocalParametricMapping(Element,3)
       double precision release_rate_tip(full_step,3)
       double precision release_rate_FEM(Element*full_step,6)
       double precision delta_ratio(full_step,5)      
       double precision eta_ratio_element(full_step*Element,5)
       double precision eta_ratio(full_step,10)
c
       double precision sum
c
       double precision gaussian_quadrature_linear
c
       integer write_file
       common /output_file/ write_file
c
c      integrate over each element
c
       do 2 n=1,full_step
        do 1 e=1,Element
         eta_ratio_element(e+(n-1)*Element,1)=time_tau(n+1,1)
         eta_ratio_element(e+(n-1)*Element,2)=time_tau(n+1,2)
         eta_ratio_element(e+(n-1)*Element,3)=FEM_mesh(e)+0.5d0*h(e)
         eta_ratio_element(e+(n-1)*Element,4)=e
         eta_ratio_element(e+(n-1)*Element,5)=
     *   gaussian_quadrature_linear
     *   (gauss_points,
     *   quadrature,     
     *   0.5d0*h(e),
     *   0.0d0,1.0d0,
     *   0.0d0,1.0d0, 
     *   release_rate_FEM(e+(n-1)*Element,5),
     *   release_rate_FEM(e+(n-1)*Element,6),
     *   LocalParametricMapping(e,2),LocalParametricMapping(e,3))
1       continue
2      continue
c
       sum=0.0d0
c
       do 4 n=1,full_step
        do 3 e=1,(time_tau(n+1,7)-1)
         sum=
     *   sum+eta_ratio_element(e+(n-1)*Element,5)
3       continue
        eta_ratio(n,3)=sum
        sum=0.0d0
4      continue
c
       sum=0.0d0
c
       do 6 n=1,full_step
        do 5 e=1,Element
         sum=
     *   sum+eta_ratio_element(e+(n-1)*Element,5)
5       continue
        eta_ratio(n,4)=sum
        sum=0.0d0
6      continue
c
       do 7 n=1,full_step
        eta_ratio(n,1)=time_tau(n+1,1)
        eta_ratio(n,2)=time_tau(n+1,2)
	 eta_ratio(n,5)=delta_ratio(n,3)
        eta_ratio(n,6)=((R0)*(R0)/(D_prime))*
     *  (delta_ratio(n,3)/eta_ratio(n,3))
     	 eta_ratio(n,7)=(delta_ratio(n,3)/eta_ratio(n,3))
     	 eta_ratio(n,8)=release_rate_tip(n,2)
     	 eta_ratio(n,9)=((R0)*(R0)/(D_prime))*
     *  ((delta_ratio(n,3))/((2*pi)*(release_rate_tip(n,2))))
	 eta_ratio(n,10)=
     *  ((delta_ratio(n,3))/((2*pi)*(release_rate_tip(n,2))))
7      continue       
c
c      export data
c
       open(20,file='eta_ratio.out')
       do 100 n=1,full_step
        write(20,*) (eta_ratio(n,j),j=1,10)
100     continue
       close(20)
c
c      end of compute residence time subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (16)
c      compute courant number DNP
c
c      this subroutine evaluates the courant number at each node
c
c      subroutine courant_number(
c    * number,full_step,
c    * Node,Element,
c    * gauss_points,
c    * quadrature,
c    * time_tau,dt,
c    * FEM_mesh,h,
c    * LocalParametricMapping,
c    * fluid_velocity_nodal,
c    * alpha_bar_nodal,
c    * peclet,
c    * peclet_grid,
c    * courant,
c    * courant_nodal,
c    * courant_grid)
c
c      variables
c
c      implicit none       
c
c      integer e,i,j,n
c      integer number,full_step
c      integer Node,Element
c      integer gauss_points
c      double precision quadrature(gauss_points,2)
c      double precision time_tau((full_step+1),7)
c      double precision dt(full_step,2)
c      double precision FEM_mesh(Node)
c      double precision h(Element)
c      double precision LocalParametricMapping(Element,3)
c      double precision fluid_velocity_nodal(Node*number,5)
c      double precision alpha_bar_nodal(Node*number,5)
c      double precision peclet(Element*number,6)
c      double precision peclet_grid(Element*full_step,5)
c      double precision courant(Element*full_step,6)
c      double precision courant_nodal(Node*full_step,5)
c      double precision courant_grid(Element*full_step,7)
c
c      double precision gaussian_quadrature_linear
c      double precision evaluation_linear
c      double precision evaluation_isoparametric_m
c      double precision evaluation_isoparametric_b
c
c      integer write_file
c      common /output_file/ write_file
c
c	calculate courant nodal marker
c
c      do 2 n=1,full_step
c       do 1 i=1,Node
c        courant_nodal(i+(n-1)*Node,1)=time_tau(n+1,1)
c        courant_nodal(i+(n-1)*Node,2)=time_tau(n+1,2)
c        courant_nodal(i+(n-1)*Node,3)=i
c        courant_nodal(i+(n-1)*Node,4)=FEM_mesh(i)
c1      continue
c2     continue 
c
c      linear interpolation functions
c      functions are stored as (m,b)
c      m*r+b
c
c      do 4 n=1,full_step
c       do 3 e=1,Element
c        courant((e+(n-1)*Element),1)=time_tau(n+1,1)
c        courant((e+(n-1)*Element),2)=e
c        courant((e+(n-1)*Element),3)=
c    *    (((((fluid_velocity_nodal(((e+1)+(n)*Node),5))*
c    *    (alpha_bar_nodal(((e+1)+(n)*Node),5)))-
c    *    ((fluid_velocity_nodal((e+(n)*Node),5))*
c    *    (alpha_bar_nodal((e+(n)*Node),5))))*
c    *    ((1)/(h(e)))))*((dt(n,2))/((h(e))))
c         courant((e+(n-1)*Element),4)=
c    *    (((((((fluid_velocity_nodal((e+(n)*Node),5))*
c    *    (alpha_bar_nodal((e+(n)*Node),5))))*
c    *    (h(e)))+
c    *    ((((fluid_velocity_nodal((e+(n)*Node),5))*
c    *    (alpha_bar_nodal((e+(n)*Node),5))))*
c    *    (FEM_mesh(e)))-
c    *    (((fluid_velocity_nodal(((e+1)+(n)*Node),5))*
c    *    (alpha_bar_nodal(((e+1)+(n)*Node),5)))*
c    *    (FEM_mesh(e))))*
c    *    (((1)/(h(e))))))*((dt(n,2))/((h(e))))
c3      continue
c4     continue
c
c      isoparametric mapping
c      the linear interpolation functions are mapped into the
c	isoparamtetric space by r --> r(xi) which is contained in
c	LocalParametricMapping matrix the coefficients form
c	iso_m*xi+iso_b and they are stored in the matrix
c      these coefficients will pass through to gaussian quadrature
c	function to be integrated in the stiffness matrix
c      they are assigned to the fm,fb in the function
c
c      do 6 n=1,full_step
c       do 5 e=1,Element
c         courant((e+(n-1)*Element),5)=
c    *    evaluation_isoparametric_m(
c    *    courant((e+(n-1)*Element),3),
c    *    LocalParametricMapping(e,2))
c         courant((e+(n-1)*Element),6)=
c    *    evaluation_isoparametric_b(
c    *    courant((e+(n-1)*Element),3),
c    *    courant((e+(n-1)*Element),4),
c    *    LocalParametricMapping(e,3))
c5      continue
c6     continue
c
c      evaluate courant number at the nodes
c
c      do 8 n=1,full_step
c       do 7 i=1,(Node-1)
c        courant_nodal(i+(n-1)*Node,5)=
c    *   evaluation_linear(
c    *   courant((i+(n-1)*Element),3),
c    *   courant((i+(n-1)*Element),4),
c    *   FEM_mesh(i))
c7      continue
c8     continue
c
c	this is for the final node, since element function f(e) would
c	provide the value at nodes i and i+1
c	so I use the final element function to evaluate at Node
c
c      do 9 n=1,full_step
c        courant_nodal(Node+(n-1)*Node,5)=
c    *   evaluation_linear(
c    *   courant((Element+(n-1)*Element),3),
c    *   courant((Element+(n-1)*Element),4),
c    *   FEM_mesh(Node))
c9     continue
c
c	evaluate the average peclet number and courant number for each
c	element
c
c      do 11 n=1,full_step
c       do 10 e=1,Element
c        peclet_grid(e+(n-1)*Element,1)=time_tau(n+1,1)
c        peclet_grid(e+(n-1)*Element,2)=dt(n,2)
c        peclet_grid(e+(n-1)*Element,3)=FEM_mesh(e)+0.5d0*h(e)
c        peclet_grid(e+(n-1)*Element,4)=e
c        courant_grid(e+(n-1)*Element,1)=time_tau(n+1,1)
c        courant_grid(e+(n-1)*Element,2)=time_tau(n+1,2)
c        courant_grid(e+(n-1)*Element,3)=FEM_mesh(e)+0.5d0*h(e)
c        courant_grid(e+(n-1)*Element,4)=e
c        peclet_grid(e+(n-1)*Element,5)=
c    *   ((1)/(h(e)))*(gaussian_quadrature_linear
c    *   (gauss_points,
c    *   quadrature,     
c    *   0.5d0*h(e),
c    *   0.0d0,1.0d0,
c    *   0.0d0,1.0d0,
c    *   peclet(e+(n)*Element,5),peclet(e+(n)*Element,6),
c    *   LocalParametricMapping(e,2),LocalParametricMapping(e,3)))
c        courant_grid(e+(n-1)*Element,5)=
c    *   ((1)/(h(e)))*(gaussian_quadrature_linear
c    *   (gauss_points,
c    *   quadrature,     
c    *   0.5d0*h(e),
c    *   0.0d0,1.0d0,
c    *   0.0d0,1.0d0,
c    *   courant(e+(n-1)*Element,5),courant(e+(n-1)*Element,6),
c    *   LocalParametricMapping(e,2),LocalParametricMapping(e,3)))
c10      continue
c11     continue
c
c	these are limits of the peclet number
c
c      do 13 n=1,full_step
c       do 12 e=1,Element
c        courant_grid(e+(n-1)*Element,6)=
c    *   (((peclet_grid(e+(n-1)*Element,5)))/
c    *   (2-peclet_grid(e+(n-1)*Element,5)))         
c        courant_grid(e+(n-1)*Element,7)=
c    *   (((peclet_grid(e+(n-1)*Element,5)))/
c    *   (2+peclet_grid(e+(n-1)*Element,5)))         
c12      continue
c13    continue
c
c      export data
c
c       open(30,file='courant_nodal.out')
c        do 100 n=1,(full_step*Node)
c         write(30,*) (courant_nodal(n,j),j=1,5)
c100     continue   
c       close(30)
c
c	open(31,file='peclet_grid.out')
c	open(32,file='courant_grid.out')
c	 do 101 n=1,(full_step*Element)
c	  write(31,*) (peclet_grid(n,j),j=1,5)
c	  write(32,*) (courant_grid(n,j),j=1,7)
c101	continue
c	close(31)
c	close(32)        
c
c      end of subroutine
c
c       return
c       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (i)
c      compute local mass matrix and local stiffness matrix
c
c      this subroutine evaluates the normalized concentration of
c      the radionuclide at the nodes for n=2 and n=3
c	(first 2 time steps, do not count t=0)
c
c	the solution utilizes the finite element method (Galerkin)
c	and a preconditoned conjugate gradient solver
c
c	there are several other subroutines within this subroutine
c
       subroutine local_FEM(
     * n,
     * number,full_step,
     * Node,Element,
     * gauss_points,
     * h,
     * quadrature,
     * alpha_bar,
     * beta_bar,
     * gamma_bar,
     * theta_bar,
     * LocalParametricMapping,
     * ShapeFunction,dShapeFunction,
     * mass,stiffness)
c
c      variables
c
       implicit none       
c
       integer e,i,j
       integer n
       integer number,full_step
       integer Node,Element
 	integer gauss_points
 	double precision h(Element)
       double precision quadrature(gauss_points,2)
       double precision alpha_bar(Element*number,6)
       double precision beta_bar(Element*number,6)
       double precision gamma_bar(Element*number,6)
       double precision theta_bar(Element*number,6)
       double precision LocalParametricMapping(Element,3)
       double precision ShapeFunction(2,2)
       double precision dShapeFunction(1,2)
       double precision mass(2*Element,2)
       double precision stiffness(2*Element,2)
c
       double precision gaussian_quadrature_linear
c
       integer write_file
       common /output_file/ write_file
c
       do 3 e=1,Element
        do 2 i=1,2
         do 1 j=1,2
          mass((i+(2*(e-1))),j)=gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    0.5d0*h(e),
     *    ShapeFunction(i,1),ShapeFunction(i,2),
     *    ShapeFunction(j,1),ShapeFunction(j,2),
     *    alpha_bar((e+(n-1)*Element),5),
     *    alpha_bar((e+(n-1)*Element),6),
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3))
          stiffness((i+(2*(e-1))),j)=(gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    0.5d0*h(e),
     *    ShapeFunction(i,1),ShapeFunction(i,2),
     *    ShapeFunction(j,1),ShapeFunction(j,2),
     *    theta_bar((e+(n-1)*Element),5),
     *    theta_bar((e+(n-1)*Element),6),
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3)))+
     *    (gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    2.0d0/h(e),
     *    0.0d0,dShapeFunction(1,i),
     *    0.0d0,dShapeFunction(1,j),
     *    gamma_bar((e+(n-1)*Element),5),
     *    gamma_bar((e+(n-1)*Element),6),
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3)))+
     *    (gaussian_quadrature_linear
     *    (gauss_points,
     *    quadrature,     
     *    1.0d0,
     *    ShapeFunction(i,1),ShapeFunction(i,2),
     *    0.0d0,dShapeFunction(1,j),
     *    beta_bar((e+(n-1)*Element),5),
     *    beta_bar((e+(n-1)*Element),6),
     *    LocalParametricMapping(e,2),LocalParametricMapping(e,3)))       
1        continue
2       continue
3      continue
c                                
       if (write_file.EQ.1) then
        if (n.EQ.2) then
         open(30,file='mass2.out')
         open(31,file='stiff2.out')
         do 100 e=1,(2*Element)
          write(30,*) (mass(e,j),j=1,2)
          write(31,*) (stiffness(e,j),j=1,2)
100      continue
        end if
        if (n.EQ.3) then
         open(30,file='mass3.out')
         open(31,file='stiff3.out')
         do 101 e=1,(2*Element)
          write(30,*) (mass(e,j),j=1,2)
          write(31,*) (stiffness(e,j),j=1,2)
101      continue
        end if
        if (n.EQ.4) then
         open(30,file='mass3.out')
         open(31,file='stiff3.out')
         do 102 e=1,(2*Element)
          write(30,*) (mass(e,j),j=1,2)
          write(31,*) (stiffness(e,j),j=1,2)
102      continue
        end if        
        if (n.EQ.9) then
         open(30,file='mass8.out')
         open(31,file='stiff8.out')
         do 103 e=1,(2*Element)
          write(30,*) (mass(e,j),j=1,2)
          write(31,*) (stiffness(e,j),j=1,2)
103      continue
        end if        
        close(30)
        close(31)
       end if
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (ii)
c      execute preconditioned conjugate gradient scheme
c
c      this subroutine evaluates the normalized concentration of
c      the radionuclide at the nodes for n=2 and n=3
c	(first 2 time steps, do not count t=0)
c
c	the solution utilizes the finite element method (Galerkin)
c	and a preconditoned conjugate gradient solver
c
c	there are several other subroutines within this subroutine
c
       subroutine PCG_solver(
     * n,
     * number,full_step,
     * Node,Element,
     * threshold,
     * delta,chi,epsilon,
     * numerator,denominator,
     * preconditioner,
     * preconditioned_stiffness,
     * preconditioned_force,
     * guess,residual,z,
     * nextstep)
c
c      variables
c
       implicit none       
c
       integer e,i,j
       integer n
       integer number,full_step
       integer Node,Element
       double precision threshold
	double precision delta,chi,epsilon
	double precision numerator,denominator
       double precision preconditioner(2*Element,2)
       double precision preconditioned_stiffness(2*Element,2)
       double precision preconditioned_force(Node)
       double precision guess(Node)
       double precision residual(Node)
       double precision z(Node)
       double precision nextstep(Node)
c
       integer write_file
       common /output_file/ write_file
c
       epsilon=100
       delta=0
       chi=0
       numerator=0
       denominator=0
c
c      prepare the PCG loop
c
c      transform the guess for the solution
c
       guess(1)=nextstep(1)*
     * ((preconditioner(1,1))**(.5))
       guess(Node)=nextstep(Node)*
     * ((preconditioner(2*Element,2))**(.5))
c     
       do 1 e=2,Element
        guess(e)=nextstep(e)*((preconditioner(2*e-2,2)+
     *  preconditioner(2*e-1,1))**(.5))
1      continue
c
c      knockout the first and last rows/columns because
c      values are known on the boundaries
c
c      the scheme is set up for a full matrix solution
c      but for boundary conditions, some matrix multiplication
c      needs to be changed
c
c      for boundary conditions, the solver obtains values for
c      Node #2 to Node #Element or (Node-1)
c
c      For the full matrix scenario do not forget to change the 
c      indices on the loops
c
       preconditioned_force(2)=
     * preconditioned_force(2)-
     * (guess(1)*preconditioned_stiffness(2,1))
       preconditioned_force(Node-1)=
     * preconditioned_force(Node-1)-
     * (guess(Node)*preconditioned_stiffness(2*Element-1,2))
c
c      calculate the first residual
c
       residual(2)=
     * preconditioned_force(2)-
     * ((preconditioned_stiffness(2,2)+preconditioned_stiffness(3,1))*
     * guess(2)+(preconditioned_stiffness(3,2)*guess(3)))
       residual(Node-1)=
     * preconditioned_force(Node-1)-
     * ((preconditioned_stiffness(2*(Node-1)-2,1)*guess((Node-1)-1))+
     * ((preconditioned_stiffness(2*(Node-1)-2,2)+
     * preconditioned_stiffness(2*(Node-1)-1,1))*guess((Node-1))))
c
       do 2 e=3,(Node-2)
        residual(e)=preconditioned_force(e)-
     *  ((preconditioned_stiffness(2*e-2,1)*guess(e-1)+
     *  (preconditioned_stiffness(2*e-2,2)+
     *  preconditioned_stiffness(2*e-1,1))*
     *  guess(e)+preconditioned_stiffness(2*e-1,2)*guess(e+1)))
2      continue
c
c      initialize the residual holder
c
       do 3 i=2,(Node-1)
        z(i)=residual(i)
3      continue
c
c      calculate the delta processor constant
c
       do 4 i=2,(Node-1)
        numerator=numerator+(z(i)*z(i))
4      continue
c
       denominator=
     * denominator+(((z(2))*(((z(2))*
     * (preconditioned_stiffness(2,2)+
     * preconditioned_stiffness(3,1)))+
     * ((z(3))*(preconditioned_stiffness(4,1)))))) 
c
       do 5 e=3,(Node-2)
        denominator=denominator+(z(e)*
     *  ((z(e-1)*preconditioned_stiffness(2*e-3,2))+
     *  (z(e)*(preconditioned_stiffness(2*e-2,2)+
     *  preconditioned_stiffness(2*e-1,1)))+
     *  (z(e+1)*preconditioned_stiffness(2*e,1))))
5      continue
c 
       denominator=denominator+(((z(Node-1))*
     * (((z(Node-2))*(preconditioned_stiffness(2*Element-3,2)))+
     * ((z(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     * preconditioned_stiffness(2*Element-1,1)))))))
c
       delta=numerator/denominator
c
c      update the guess with the processor constant
c      this guess vector will be used in the PCG loop
c
       do 6 i=2,(Node-1)
        guess(i)=guess(i)+delta*z(i)
6      continue
c
c      start the PCG loop
c
       do while (epsilon.GT.threshold)
c
c      calculate the residual
c
        residual(2)=
     *  preconditioned_force(2)-((preconditioned_stiffness(2,2)+
     *  preconditioned_stiffness(3,1))*guess(2)+
     *  (preconditioned_stiffness(3,2)*guess(3)))
        residual(Node-1)=
     *  preconditioned_force((Node-1))-
     *  ((preconditioned_stiffness(2*(Node-1)-2,1)*guess((Node-1)-1))+
     *  ((preconditioned_stiffness(2*(Node-1)-2,2)+
     *  preconditioned_stiffness(2*(Node-1)-1,1))*guess((Node-1))))
c
        do 7 e=3,(Node-2)
         residual(e)=
     *   preconditioned_force(e)-
     *   ((preconditioned_stiffness(2*e-2,1)*guess(e-1)+
     *   (preconditioned_stiffness(2*e-2,2)+
     *   preconditioned_stiffness(2*e-1,1))*guess(e)+
     *   preconditioned_stiffness(2*e-1,2)*guess(e+1)))
7       continue
c
c      calculate the chi processor constant
c
        numerator=0
        denominator=0
c
        numerator=numerator+(((z(2))*(((residual(2))*
     *  (preconditioned_stiffness(2,2)+preconditioned_stiffness(3,1)))+
     *  ((residual(3))*(preconditioned_stiffness(4,1))))))  
c
        do 8 e=3,(Node-2)
         numerator=numerator+(z(e)*((residual(e-1)*
     *   preconditioned_stiffness(2*e-3,2))+(residual(e)*
     *   (preconditioned_stiffness(2*e-2,2)+
     *   preconditioned_stiffness(2*e-1,1)))+
     *   (residual(e+1)*preconditioned_stiffness(2*e,1))))
8       continue
c
        numerator=numerator+(((z(Node-1))*
     *  (((residual(Node-2))*(preconditioned_stiffness(2*Element-3,2)))+
     *  ((residual(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     *  preconditioned_stiffness(2*Element-1,1)))))))
c
        denominator=denominator+(((z(2))*
     *  (((z(2))*(preconditioned_stiffness(2,2)+
     *  preconditioned_stiffness(3,1)))+((z(3))*
     *  (preconditioned_stiffness(4,1))))))
c
        do 9 e=3,(Node-2)
         denominator=denominator+(z(e)*((z(e-1)*
     *    preconditioned_stiffness(2*e-3,2))+(z(e)*
     *    (preconditioned_stiffness(2*e-2,2)+
     *    preconditioned_stiffness(2*e-1,1)))+
     *    (z(e+1)*preconditioned_stiffness(2*e,1))))
9       continue
c 
        denominator=denominator+(((z(Node-1))*
     *  (((z(Node-2))*(preconditioned_stiffness(2*Element-3,2)))+
     *  ((z(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     *  preconditioned_stiffness(2*Element-1,1)))))))
c
        chi=(-1)*(numerator/denominator)
c
c      update z with the processor constant
c
        do 10 i=2,(Node-1)
         z(i)=residual(i)+chi*z(i)
10      continue
c
c      calculate the delta processor constant
c
        delta=0
        numerator=0
        denominator=0
c
        do 11 i=2,(Node-1)
         numerator=numerator+(z(i)*residual(i))
11      continue
c
        denominator=denominator+(((z(2))*(((z(2))*
     *  (preconditioned_stiffness(2,2)+
     *  preconditioned_stiffness(3,1)))+((z(3))*
     *  (preconditioned_stiffness(4,1)))))) 
c
        do 12 e=3,(Node-2)
         denominator=denominator+(z(e)*((z(e-1)*
     *   preconditioned_stiffness(2*e-3,2))+
     *   (z(e)*(preconditioned_stiffness(2*e-2,2)+
     *   preconditioned_stiffness(2*e-1,1)))+
     *   (z(e+1)*preconditioned_stiffness(2*e,1))))
12      continue
c 
        denominator=denominator+(((z(Node-1))*(((z(Node-2))*
     *  (preconditioned_stiffness(2*Element-3,2)))+
     *  ((z(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     *  preconditioned_stiffness(2*Element-1,1)))))))
c
        delta=numerator/denominator
c        
c      update the guess with the processor constant
c
        do 13 i=1,Node
         guess(i)=guess(i)+delta*z(i)
13      continue
c
        numerator=0
        denominator=0
c
        numerator=numerator+(((z(2))*(((z(2))*
     *  (preconditioned_stiffness(2,2)+preconditioned_stiffness(3,1)))+
     *  ((z(3))*(preconditioned_stiffness(4,1))))))
c
        do 14 e=3,(Node-2)
         numerator=numerator+(z(e)*((z(e-1)*
     *   preconditioned_stiffness(2*e-3,2))+
     *   (z(e)*(preconditioned_stiffness(2*e-2,2)+
     *   preconditioned_stiffness(2*e-1,1)))+
     *   (z(e+1)*preconditioned_stiffness(2*e,1))))
14      continue
c
        numerator=numerator+(((z(Node-1))*(((z(Node-2))*
     *  (preconditioned_stiffness(2*Element-3,2)))+
     *  ((z(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     *  preconditioned_stiffness(2*Element-1,1)))))))
c
        denominator=denominator+(((guess(2))*(((guess(2))*
     *  (preconditioned_stiffness(2,2)+preconditioned_stiffness(3,1)))+
     *  ((guess(3))*(preconditioned_stiffness(4,1))))))
c
        do 15 e=3,(Node-2)
         denominator=denominator+(guess(e)*
     *   ((guess(e-1)*preconditioned_stiffness(2*e-3,2))+
     *   (guess(e)*(preconditioned_stiffness(2*e-2,2)+
     *   preconditioned_stiffness(2*e-1,1)))+
     *   (guess(e+1)*preconditioned_stiffness(2*e,1))))
15      continue
c 
        denominator=denominator+(((guess(Node-1))*
     *  (((guess(Node-2))*(preconditioned_stiffness(2*Element-3,2)))+
     *  ((guess(Node-1))*((preconditioned_stiffness(2*Element-2,2)+
     *  preconditioned_stiffness(2*Element-1,1)))))))
c
        epsilon=(abs(delta))*(numerator/denominator)
c
c      end of the PCG loop
c
	write(6,*) 'PCG',n,epsilon
c
       end do
c
       if (write_file.EQ.1) then
        if (n.EQ.2) then
         open(30,file='guess2.out')
         open(31,file='epsilon2.out')
         do 100 i=1,Node
          write(30,*) (guess(i))
100      continue
          write(31,*) epsilon
        end if
        if (n.EQ.3) then
         open(30,file='guess3.out')
         open(31,file='epsilon3.out')
         do 101 i=1,Node
          write(30,*) (guess(i))
101      continue
         write(31,*) epsilon
        end if
        if (n.EQ.4) then
         open(30,file='guess4.out')
         open(31,file='epsilon4.out')
         do 102 e=1,(2*Element)
          write(30,*) (guess(i))
102      continue
         write(31,*) epsilon
        end if        
        if (n.EQ.9) then
         open(30,file='guess9.out')
         open(31,file='epsilon9.out')
         do 103 i=1,Node
          write(30,*) (guess(i))
103      continue
         write(31,*) epsilon
        end if        
        close(30)
        close(31)
       end if
c
c      end of subroutine
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c      functions
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (a)
c      evaluation for linear functions
c	
c	this function computes a value given a linear function
c      with slope (m), intercept (b), and position (r,xi)
c
       double precision function evaluation_linear(m,b,xi)
c
	implicit none
	double precision m,b,xi
c
	evaluation_linear=m*xi+b
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (b)
c      evaluation for fluid porosity
c	
c	this function computes the fluid porosity at the nodes
c      with nodal void ratio distribution (m)
c
       double precision function evaluation_fluid_porosity(m)
c
	implicit none
	double precision m
c
	evaluation_fluid_porosity=((m)/(1+m))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (c)
c      evaluation for solid porosity
c	
c	this function computes the solid porosity at the nodes
c      with nodal void ratio distribution (m)
c
       double precision function evaluation_solid_porosity(m)
c
	implicit none
	double precision m
c
	evaluation_solid_porosity=((1)/(1+m))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (d)
c      evaluation for retardation
c	
c	this function computes the retardation at the nodes
c      with nodal void ratio distribution (m)
c      and sorption distribution coefficient (b)
c
       double precision function evaluation_retardation(m,b)
c
	implicit none
	double precision m
	double precision b
c
	evaluation_retardation=1+((b)/(m))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (e)
c      evaluation for A matrix
c	
c	this function computes the A matrix at the nodes
c      with nodal void ratio distribution (m)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient (d1)
c      solid diffusion coefficient (d2)
c      void diffusivity (p,q)
c
       double precision function evaluation_A_matrix(m,b,d1,d2,p,q)
c
	implicit none
	double precision m
	double precision b
	double precision d1,d2
	double precision p,q
c
	evaluation_A_matrix=(1-b)+(((d1)-(d2*b))/((p)*(exp(q*m))))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (f)
c      evaluation for B matrix
c	
c	this function computes the B matrix at the nodes
c      with nodal void ratio distribution (m)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient (d1)
c      solid diffusion coefficient (d2)
c
       double precision function evaluation_B_matrix(m,b,d1,d2)
c
	implicit none
	double precision m
	double precision b
	double precision d1,d2
c
	evaluation_B_matrix=1+((b*d2)/(m*d1))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (g)
c      evaluation for fluid velocity in extrusion region
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      radius (x)
c      void diffusivity (p,q)
c
       double precision function evaluation_fluid_velocity(m,dm,x,p,q)
c
	implicit none
	double precision m
	double precision dm
	double precision x
	double precision p,q
c
	double precision evaluation_void_diffusivity
c
	evaluation_fluid_velocity=
     * (-1)*(1/x)*(dm)*((evaluation_void_diffusivity(m,p,q))/(m))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (h)
c      evaluation for fluid velocity in region beyond extruding tip
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      node (xi)
c      dimensionless tip location (x)
c      void diffusivity (p,q)
c      radius (x1)
c
       double precision function evaluation_fluid_velocity_tip(
     * m,dm,xi,x,p,q,x1)
c
	implicit none
	double precision m
	double precision dm
	double precision xi
	double precision x
	double precision p,q
	double precision x1
c
       double precision evaluation_fluid_porosity
       double precision evaluation_fluid_velocity
c       
	evaluation_fluid_velocity_tip=
     * (x/xi)*evaluation_fluid_porosity(m)*
     * evaluation_fluid_velocity(m,dm,x1,p,q)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (i)
c      evaluation for solid velocity in extrusion region
c	
c	this function computes the solid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      radius (x)
c      void diffusivity (p,q)
c
       double precision function evaluation_solid_velocity(m,dm,x,p,q)
c
	implicit none
	double precision m
	double precision dm
	double precision x
	double precision p,q
c
	double precision evaluation_void_diffusivity
c
	evaluation_solid_velocity=(1/x)*(dm)*
     * (evaluation_void_diffusivity(m,p,q))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (j)
c      evaluation for peclet number in extrusion region
c	
c	this function computes the peclet number at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      radius (x)
c      fluid diffusion coefficent (d1)
c      void diffusivity (p,q)
c
       double precision function evaluation_peclet(m,dm,x,d1,p,q)
c
	implicit none
	double precision m
	double precision dm
	double precision x
	double precision d1
	double precision p,q
c
       double precision evaluation_fluid_velocity
c       
	evaluation_peclet=(x/d1)*evaluation_fluid_velocity(m,dm,x,p,q)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (k)
c      evaluation for peclet number in region beyond extruding tip
c	
c	this function computes the peclet at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      node (xi)
c      dimensionless tip location (x)
c      void diffusivity (p,q)
c      radius (x1)
c
       double precision function evaluation_peclet_tip(
     * m,dm,xi,x,d1,p,q,x1)
c
	implicit none
	double precision m
	double precision dm
	double precision xi
	double precision x
	double precision d1
	double precision p,q
	double precision x1
c
       double precision evaluation_fluid_velocity_tip
c       
	evaluation_peclet_tip=(x1/d1)*
     * evaluation_fluid_velocity_tip(m,dm,xi,x,p,q,x1)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (l)
c      evaluation for alpha bar
c	
c	this function computes alpha bar at the nodes
c      with nodal void ratio distribution (m)
c      sorption distribution coefficient (b)
c
       double precision function evaluation_alpha_bar(m,b)
c
	implicit none
	double precision m
	double precision b
c
       double precision evaluation_fluid_porosity
       double precision evaluation_retardation
c       
	evaluation_alpha_bar=evaluation_fluid_porosity(m)*
     * evaluation_retardation(m,b)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (m)
c      evaluation for beta bar in bentonite extrusion region
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient (d1)
c      fluid diffusion coefficient normalized (d2)
c      solid diffusion coefficient normalized (d3)
c      void diffusivity (p,q)
c      radius (x)
c 
       double precision function evaluation_beta_bar
     * (m,dm,b,d1,d2,d3,p,q,x)
c
	implicit none
	double precision m
	double precision dm
       double precision b
      	double precision d1
	double precision d2
	double precision d3
	double precision p,q
	double precision x
c
       double precision evaluation_fluid_porosity
       double precision evaluation_solid_porosity
       double precision evaluation_void_diffusivity
       double precision evaluation_peclet
       double precision evaluation_dfluid_porosity
c       
	evaluation_beta_bar=((evaluation_fluid_porosity(m))*
     * (evaluation_peclet(m,dm,x,d1,p,q))*(1-b))-
     * ((evaluation_dfluid_porosity(m,dm))*(d2-d3*b))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (n)
c      evaluation for beta bar in region beyond extruding tip
c	
c	this function computes the peclet at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      node (xi)
c      dimensionless tip location (x)
c      void diffusivity (p,q)
c      radius (x1)
c      fluid porosity physical (fp)
c      A physical (a)
c
       double precision function evaluation_beta_bar_tip(
     * m,dm,xi,x,d1,p,q,x1,fp,a)
c
	implicit none
	double precision m
	double precision dm
	double precision xi
	double precision x
	double precision d1
	double precision p,q
	double precision x1
	double precision fp
	double precision a
c
       double precision evaluation_peclet_tip
c       
	evaluation_beta_bar_tip=fp*
     * evaluation_peclet_tip(m,dm,xi,x,d1,p,q,x1)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (o)
c      evaluation for gamma bar
c	
c	this function computes the gamma bar at the nodes
c      with nodal void ratio distribution (m)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient normalized (d1)
c      solid diffusion coefficient normalized (d2)
c
       double precision function evaluation_gamma_bar(m,b,d1,d2)
c
	implicit none
	double precision m
	double precision b
	double precision d1,d2
c
       double precision evaluation_fluid_porosity
       double precision evaluation_solid_porosity
c       
	evaluation_gamma_bar=(d1)*(evaluation_fluid_porosity(m))+
     * (d2)*(b)*(evaluation_solid_porosity(m))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (p)
c      evaluation for theta bar in bentonite extrusion region
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient (d1)
c      fluid diffusion coefficient normalized (d2)
c      solid diffusion coefficient normalized (d3)
c      void diffusivity (p,q)
c      radius (x)
c      dt (delta_t)
c      theta_bar_physical/thiele (l)
c      node (xi)
c      nodal alpha bar value at current time step (an)
c      nodal alpha bar value at previous time step (ap)
c 
       double precision function evaluation_theta_bar
     * (m,dm,b,d1,d2,d3,p,q,x,delta_t,l,xi,an,ap)
c
	implicit none
	double precision m
	double precision dm
       double precision b
      	double precision d1
	double precision d2
	double precision d3
	double precision p,q
	double precision x
	double precision delta_t
	double precision l
	double precision xi
	double precision an
	double precision ap
c
       double precision evaluation_alpha_bar
       double precision evaluation_beta_bar
       double precision evaluation_dbeta_bar
       double precision evaluation_dalpha_bar
c       
	evaluation_theta_bar=
     * evaluation_alpha_bar(m,b)*l+
     * (1/xi)*evaluation_beta_bar(m,dm,b,d1,d2,d3,p,q,x)+
     * evaluation_dbeta_bar(m,dm,b,d1,d2,d3,p,q,xi,x)+
     * evaluation_dalpha_bar(an,ap,b,delta_t)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (p)
c      evaluation for theta bar in region beyond extruding tip
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      node (xi)
c      dimensionless tip location (x)
c      fluid diffusion coefficient (d1)
c      void diffusivity (p,q)
c      radius (x1)
c      A physical (a)
c      alpha bar physical (ab)
c      theta_bar_physical/thiele (l)
c      fluid porosity physical (fp)
c 
       double precision function evaluation_theta_bar_tip
     * (m,dm,xi,x,d1,p,q,x1,a,ab,l,fp)
c
	implicit none
	double precision m
	double precision dm
       double precision xi
      	double precision x
	double precision d1
	double precision p,q
	double precision x1
	double precision a
	double precision ab
	double precision l
	double precision fp
c
       double precision evaluation_beta_bar_tip
       double precision evaluation_dbeta_bar_tip
c       
	evaluation_theta_bar_tip=
     * ab*l+
     * (1/xi)*evaluation_beta_bar_tip(
     * m,dm,xi,x,d1,p,q,x1,fp,a)+
     * evaluation_dbeta_bar_tip(m,dm,xi,x,d1,p,q,x1,fp,a)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (r)
c      evaluation for alpha bar derivative in bentonite extrusion region
c	
c	this function computes derivative of alpha bar at the nodes
c      nodal alpha bar value at current time step (an)
c      nodal alpha bar value at previous time step (ap)
c      dt (delta_t)
c 
       double precision function evaluation_dalpha_bar
     * (an,ap,b,delta_t)
c
	implicit none
	double precision an
	double precision ap
	double precision b
       double precision delta_t
c
	evaluation_dalpha_bar=((((an+b)/(1+an))-((ap+b)/(1+ap))))/
     * (delta_t)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (s)
c      evaluation for beta bar derivative in bentonite extrusion region
c	
c	this function computes the fluid velocity at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      sorption distribution coefficient (b)
c      fluid diffusion coefficient (d1)
c      fluid diffusion coefficient normalized (d2)
c      solid diffusion coefficient normalized (d3)
c      void diffusivity (p,q)
c      node (xi)
c	radius (x)
c 
       double precision function evaluation_dbeta_bar
     * (m,dm,b,d1,d2,d3,p,q,xi,x)
c
	implicit none
	double precision m
	double precision dm
       double precision b
      	double precision d1
	double precision d2
	double precision d3
	double precision p,q
	double precision xi
	double precision x
c
	double precision evaluation_fluid_porosity
	double precision evaluation_solid_porosity
	double precision evaluation_fluid_velocity
	double precision evaluation_void_diffusivity
	double precision evaluation_d2void_ratio_derivative
c	
	evaluation_dbeta_bar=((-1)*(((x)*(1-b))/(d1))*
     * (((evaluation_fluid_porosity(m))*
     * (evaluation_fluid_velocity(m,dm,x,p,q))*(dm)*
     * ((2*evaluation_solid_porosity(m))-(q)))+
     * ((evaluation_solid_porosity(m))*
     * ((evaluation_void_diffusivity(m,p,q))/(x))*
     * (evaluation_d2void_ratio_derivative(m,dm,q,xi)))))-
     * (((d2)-(d3*b))*
     * ((((1)/((1+m)*(1+m)))*
     * (evaluation_d2void_ratio_derivative(m,dm,q,xi)))-
     * (((2)/((1+m)*(1+m)*(1+m)))*(dm)*(dm))))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (t)
c      evaluation for beta bar derivative in region beyond extruding tip
c	
c	this function computes the peclet at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      node (xi)
c      dimensionless tip location (x)
c      void diffusivity (p,q)
c      radius (x1)
c      fluid porosity physical (fp)
c      A physical (a)
c
       double precision function evaluation_dbeta_bar_tip(
     * m,dm,xi,x,d1,p,q,x1,fp,a)
c
	implicit none
	double precision m
	double precision dm
	double precision xi
	double precision x
	double precision d1
	double precision p,q
	double precision x1
	double precision fp
	double precision a
c
       double precision evaluation_beta_bar_tip
c       
	evaluation_dbeta_bar_tip=(-1)*(1/xi)*
     * evaluation_beta_bar_tip(m,dm,xi,x,d1,p,q,x1,fp,a)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (u)
c      isoparametric mapping slope
c	
c	this function performs isoparametric mapping for the 
c	dimensionless parameters
c      the function is given as m*r+b
c      to map r --> r(xi)
c      the isoparametric function is given as iso_map_m*xi+iso_map_b
c      so, the mapping function becomes (m*iso_map_m)*xi+(m*iso_map_b+b)
c
c      argument order is critical
c      1: m
c      2: iso_map_m
c
c      
       double precision function evaluation_isoparametric_m(
     * m,iso_map_m)
c
	implicit none
	double precision m
	double precision iso_map_m	
c
       evaluation_isoparametric_m=m*iso_map_m
c
c      end of isoparametric mapping function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (v)
c      isoparametric mapping intercept
c	
c	this function performs isoparametric mapping for the 
c	dimensionless parameters
c      the function is given as m*r+b
c      to map r --> r(xi)
c      the isoparametric function is given as iso_map_m*xi+iso_map_b
c      so, the mapping function becomes (m*iso_map_m)*xi+(m*iso_map_b+b)
c
c      argument order is critical
c      1: m
c      2: b
c      2: iso_map_b
c
c      
       double precision function evaluation_isoparametric_b(
     * m,b,iso_map_b)
c
	implicit none
	double precision m,b
	double precision iso_map_b	
c
       evaluation_isoparametric_b=m*iso_map_b+b
c
c      end of isoparametric mapping function
c
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (z)
c      gaussian quadrature for linear functions
c	
c	this function performs numerical integration
c      in the isoparametric space for a linear function
c      m*xi+b
c
c      argument order is critical
c      this works for FEM integration
c      energy norm calculation
c      ratio calculation
c
c      1: number of gauss points
c      2: gaussian values
c      3: jacobian
c      4: m for shape function 1/dradionuclide_FEM
c      5: b for shape function 1/dradionuclide_FEM
c      6: m for shape function 2/dradionuclide_FEM/radionuclide_FEM
c      7: b for shape function 2/dradionuclide_FEM/radionuclide_FEM
c      8: m for function
c      9: b for function
c      10: m for the isoparametric function r(xi)
c      11: b for the isoparametric function r(xi)
c
c      if there is a deriviative of the shape function
c      then put the derivative in the b slot
c      and let m = 0 in the function call
c
c      if there is no function then put m=0,b=1
c
c      this function inherently contains the 2*pi
c      
       double precision function gaussian_quadrature_linear(
     * gauss_points,quadrature,jacobian,m1,b1,m2,b2,
     * fm,fb,iso_map_m,iso_map_b)
c
	implicit none
	integer i,j
	integer gauss_points
	double precision pi
	parameter(pi=3.14159265358979)
	double precision jacobian	
	double precision m1,b1
	double precision m2,b2
	double precision fm,fb
	double precision iso_map_m,iso_map_b
	double precision integral_response
	double precision quadrature(gauss_points,2)
	double precision local_quadrature(gauss_points)
c
       double precision evaluation_linear
c
       integral_response=0.0d0
c       
       do 1 i=1,gauss_points
        local_quadrature(i)=quadrature(i,1)*
     *  (2*pi*jacobian*
     *  evaluation_linear(m1,b1,quadrature(i,2))*
     *  evaluation_linear(m2,b2,quadrature(i,2))*
     *  evaluation_linear(fm,fb,quadrature(i,2))*
     *  evaluation_linear(iso_map_m,iso_map_b,quadrature(i,2)))
1      continue
c
       do 2 j=1,gauss_points
        integral_response=integral_response+local_quadrature(j)
2      continue
c
       gaussian_quadrature_linear=integral_response
c
c      end of gaussian quadrature function
c
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (aa)
c      evaluation of void diffusivity
c	
c	this function computes void diffusivity at the nodes
c      with nodal void ratio distribution (m)
c      and void diffusivity (p,q)
c
       double precision function evaluation_void_diffusivity(m,p,q)
c
	implicit none
	double precision m
	double precision p,q
c
	evaluation_void_diffusivity=(p*exp(q*m))/(1+m)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (w)
c      evaluation for derivative of fluid porosity
c	
c	this function computes the derivative of fluid porosity at the nodes
c      with nodal void ratio distribution (m)
c      and derivative void ratio distribution (dm)
c
       double precision function evaluation_dfluid_porosity(m,dm)
c
	implicit none
	double precision m
	double precision dm
c
	evaluation_dfluid_porosity=((1)/((1+m)*(1+m)))*(dm)
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      (x)
c      evaluation for second order derivative of void ratio
c	
c	this function computes the second order derivative of void ratio at the nodes
c      with nodal void ratio distribution (m)
c      derivative void ratio distribution (dm)
c      void diffusivity (q)
c      and node (xi)
c
       double precision function evaluation_d2void_ratio_derivative
     * (m,dm,q,xi)
c
	implicit none
	double precision m
	double precision dm
	double precision q
	double precision xi
c
	evaluation_d2void_ratio_derivative=((-1)*(1/xi)*(dm))-
     * (((((q)*(1+m))-(1))/(1+m))*(dm)*(dm))
c
c      end of evaluation function
c
       return
       end
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c	This is the end of the entire file
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
